<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Eigen::SparseLU&lt; MatrixType_, OrderingType_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.4.90 (git rev 2d4c9b400cca33d2f5cf316efc7151236244edb1)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classEigen_1_1SparseLU.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="classEigen_1_1SparseLU-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">Eigen::SparseLU&lt; MatrixType_, OrderingType_ &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Sparse__chapter.html">Sparse linear algebra</a> &raquo; <a class="el" href="group__Sparse__Reference.html">Reference</a> &raquo; <a class="el" href="group__SparseLU__Module.html">SparseLU module</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename MatrixType_, typename OrderingType_&gt;<br />
class Eigen::SparseLU&lt; MatrixType_, OrderingType_ &gt;</div><p><a class="el" href="structEigen_1_1Sparse.html">Sparse</a> supernodal LU factorization for general matrices. </p>
<p>This class implements the supernodal LU factorization for general matrices. It uses the main techniques from the sequential <a class="el" href="classEigen_1_1SuperLU.html" title="A sparse direct LU factorization and solver based on the SuperLU library.">SuperLU</a> package (<a href="http://crd-legacy.lbl.gov/~xiaoye/SuperLU/">http://crd-legacy.lbl.gov/~xiaoye/SuperLU/</a>). It handles transparently real and complex arithmetic with single and double precision, depending on the scalar type of your input matrix. The code has been optimized to provide BLAS-3 operations during supernode-panel updates. It benefits directly from the built-in high-performant <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> BLAS routines. Moreover, when the size of a supernode is very small, the BLAS calls are avoided to enable a better optimization from the compiler. For best performance, you should compile it with NDEBUG flag to avoid the numerous bounds checking on vectors.</p>
<p>An important parameter of this class is the ordering method. It is used to reorder the columns (and eventually the rows) of the matrix to reduce the number of new elements that are created during numerical factorization. The cheapest method available is COLAMD. See <a class="el" href="group__OrderingMethods__Module.html">the OrderingMethods module </a> for the list of built-in and external ordering methods.</p>
<p>Simple example with key steps </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">VectorXd</a> x(n), b(n);</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1SparseMatrix.html">SparseMatrix&lt;double&gt;</a> A;</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1SparseLU.html">SparseLU&lt;SparseMatrix&lt;double&gt;</a>, <a class="code hl_class" href="classEigen_1_1COLAMDOrdering.html">COLAMDOrdering&lt;int&gt;</a> &gt; solver;</div>
<div class="line"><span class="comment">// Fill A and b.</span></div>
<div class="line"><span class="comment">// Compute the ordering permutation vector from the structural pattern of A.</span></div>
<div class="line">solver.<a class="code hl_function" href="#aa907ff958c4f4855145091d2686f3a8a">analyzePattern</a>(A);</div>
<div class="line"><span class="comment">// Compute the numerical factorization.</span></div>
<div class="line">solver.<a class="code hl_function" href="#a39858b0e72f2659d596364e252b34cbc">factorize</a>(A);</div>
<div class="line"><span class="comment">// Use the factors to solve the linear system.</span></div>
<div class="line">x = solver.<a class="code hl_function" href="#a08a74a14996766dc6aba667590aa27b8">solve</a>(b);</div>
<div class="ttc" id="aclassEigen_1_1COLAMDOrdering_html"><div class="ttname"><a href="classEigen_1_1COLAMDOrdering.html">Eigen::COLAMDOrdering</a></div><div class="ttdef"><b>Definition</b> Ordering.h:109</div></div>
<div class="ttc" id="aclassEigen_1_1Matrix_html"><div class="ttname"><a href="classEigen_1_1Matrix.html">Eigen::Matrix</a></div><div class="ttdoc">The matrix class, also used for vectors and row-vectors.</div><div class="ttdef"><b>Definition</b> Matrix.h:186</div></div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html"><div class="ttname"><a href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a></div><div class="ttdoc">Sparse supernodal LU factorization for general matrices.</div><div class="ttdef"><b>Definition</b> SparseLU.h:151</div></div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_a08a74a14996766dc6aba667590aa27b8"><div class="ttname"><a href="#a08a74a14996766dc6aba667590aa27b8">Eigen::SparseLU::solve</a></div><div class="ttdeci">const Solve&lt; SparseLU, Rhs &gt; solve(const MatrixBase&lt; Rhs &gt; &amp;B) const</div><div class="ttdoc">Solve a system .</div></div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_a39858b0e72f2659d596364e252b34cbc"><div class="ttname"><a href="#a39858b0e72f2659d596364e252b34cbc">Eigen::SparseLU::factorize</a></div><div class="ttdeci">void factorize(const MatrixType &amp;matrix)</div><div class="ttdoc">Factorize the matrix to get the solver ready.</div><div class="ttdef"><b>Definition</b> SparseLU.h:611</div></div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_aa907ff958c4f4855145091d2686f3a8a"><div class="ttname"><a href="#aa907ff958c4f4855145091d2686f3a8a">Eigen::SparseLU::analyzePattern</a></div><div class="ttdeci">void analyzePattern(const MatrixType &amp;matrix)</div><div class="ttdoc">Compute the column permutation.</div><div class="ttdef"><b>Definition</b> SparseLU.h:528</div></div>
<div class="ttc" id="aclassEigen_1_1SparseMatrix_html"><div class="ttname"><a href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a></div><div class="ttdoc">A versatible sparse matrix representation.</div><div class="ttdef"><b>Definition</b> SparseUtil.h:47</div></div>
</div><!-- fragment --><p>We can directly call <a class="el" href="#a5b509284ea760c16df0a199a02222706" title="Analyze and factorize the matrix so the solver is ready to solve.">compute()</a> instead of <a class="el" href="#aa907ff958c4f4855145091d2686f3a8a" title="Compute the column permutation.">analyzePattern()</a> and <a class="el" href="#a39858b0e72f2659d596364e252b34cbc" title="Factorize the matrix to get the solver ready.">factorize()</a> </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">VectorXd</a> x(n), b(n);</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1SparseMatrix.html">SparseMatrix&lt;double&gt;</a> A;</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1SparseLU.html">SparseLU&lt;SparseMatrix&lt;double&gt;</a>, <a class="code hl_class" href="classEigen_1_1COLAMDOrdering.html">COLAMDOrdering&lt;int&gt;</a> &gt; solver;</div>
<div class="line"><span class="comment">// Fill A and b.</span></div>
<div class="line">solver.<a class="code hl_function" href="#a5b509284ea760c16df0a199a02222706">compute</a>(A);</div>
<div class="line"><span class="comment">// Use the factors to solve the linear system.</span></div>
<div class="line">x = solver.<a class="code hl_function" href="#a08a74a14996766dc6aba667590aa27b8">solve</a>(b);</div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_a5b509284ea760c16df0a199a02222706"><div class="ttname"><a href="#a5b509284ea760c16df0a199a02222706">Eigen::SparseLU::compute</a></div><div class="ttdeci">void compute(const MatrixType &amp;matrix)</div><div class="ttdoc">Analyze and factorize the matrix so the solver is ready to solve.</div><div class="ttdef"><b>Definition</b> SparseLU.h:210</div></div>
</div><!-- fragment --><p>Or give the matrix to the constructor <a class="el" href="#ae5a97ebfe407d2c3597b71afefa266a1" title="Constructor of the solver already based on a specific matrix.">SparseLU(const MatrixType&amp; matrix)</a> </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">VectorXd</a> x(n), b(n);</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1SparseMatrix.html">SparseMatrix&lt;double&gt;</a> A;</div>
<div class="line"><span class="comment">// Fill A and b.</span></div>
<div class="line"><a class="code hl_class" href="classEigen_1_1SparseLU.html">SparseLU&lt;SparseMatrix&lt;double&gt;</a>, <a class="code hl_class" href="classEigen_1_1COLAMDOrdering.html">COLAMDOrdering&lt;int&gt;</a> &gt; solver(A);</div>
<div class="line"><span class="comment">// Use the factors to solve the linear system.</span></div>
<div class="line">x = solver.<a class="code hl_function" href="#a08a74a14996766dc6aba667590aa27b8">solve</a>(b);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The input matrix A should be in a <b>compressed</b> and <b>column-major</b> form. Otherwise an expensive copy will be made. You can call the inexpensive makeCompressed() to get a compressed matrix.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike the initial <a class="el" href="classEigen_1_1SuperLU.html" title="A sparse direct LU factorization and solver based on the SuperLU library.">SuperLU</a> implementation, there is no step to equilibrate the matrix. For badly scaled matrices, this step can be useful to reduce the pivoting during factorization. If this is the case for your matrices, you can try the basic scaling method at "unsupported/Eigen/src/IterativeSolvers/Scaling.h"</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType_</td><td>The type of the sparse matrix. It must be a column-major SparseMatrix&lt;&gt; </td></tr>
    <tr><td class="paramname">OrderingType_</td><td>The ordering method to use, either AMD, COLAMD or METIS. Default is COLMAD</td></tr>
  </table>
  </dd>
</dl>
<p>This class follows the <a class="el" href="group__TopicSparseSystems.html#TutorialSparseSolverConcept">sparse solver concept </a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TopicSparseSystems.html#TutorialSparseSolverConcept">Sparse solver concept</a> </dd>
<dd>
<a class="el" href="group__OrderingMethods__Module.html">OrderingMethods module</a> </dd></dl>
</div><div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Eigen::SparseLU&lt; MatrixType_, OrderingType_ &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classEigen_1_1SparseLU__inherit__graph.png" border="0" usemap="#aEigen_1_1SparseLU_3_01MatrixType___00_01OrderingType___01_4_inherit__map" alt="Inheritance graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9607aab8ecb951b12a80dce2c39f44e8" id="r_a9607aab8ecb951b12a80dce2c39f44e8"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9607aab8ecb951b12a80dce2c39f44e8">absDeterminant</a> ()</td></tr>
<tr class="memdesc:a9607aab8ecb951b12a80dce2c39f44e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the absolute value of the determinant.  <br /></td></tr>
<tr class="separator:a9607aab8ecb951b12a80dce2c39f44e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dc8970973e010a7876398ab3f47332" id="r_a25dc8970973e010a7876398ab3f47332"><td class="memItemLeft" align="right" valign="top">const SparseLUTransposeView&lt; true, <a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a>&lt; MatrixType_, OrderingType_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25dc8970973e010a7876398ab3f47332">adjoint</a> ()</td></tr>
<tr class="memdesc:a25dc8970973e010a7876398ab3f47332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a solver for the adjointed matrix.  <br /></td></tr>
<tr class="separator:a25dc8970973e010a7876398ab3f47332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa907ff958c4f4855145091d2686f3a8a" id="r_aa907ff958c4f4855145091d2686f3a8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa907ff958c4f4855145091d2686f3a8a">analyzePattern</a> (const MatrixType &amp;matrix)</td></tr>
<tr class="memdesc:aa907ff958c4f4855145091d2686f3a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the column permutation.  <br /></td></tr>
<tr class="separator:aa907ff958c4f4855145091d2686f3a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1291267c41e1f474ba637be8a8e1dc" id="r_a0b1291267c41e1f474ba637be8a8e1dc"><td class="memItemLeft" align="right" valign="top"><a id="a0b1291267c41e1f474ba637be8a8e1dc" name="a0b1291267c41e1f474ba637be8a8e1dc"></a>
<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cols</b> () const</td></tr>
<tr class="memdesc:a0b1291267c41e1f474ba637be8a8e1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the number of columns. <br /></td></tr>
<tr class="separator:a0b1291267c41e1f474ba637be8a8e1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fd18705475738bf1a950f9dfb0a49a" id="r_a69fd18705475738bf1a950f9dfb0a49a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69fd18705475738bf1a950f9dfb0a49a">colsPermutation</a> () const</td></tr>
<tr class="memdesc:a69fd18705475738bf1a950f9dfb0a49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the column matrix permutation.  <br /></td></tr>
<tr class="separator:a69fd18705475738bf1a950f9dfb0a49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b509284ea760c16df0a199a02222706" id="r_a5b509284ea760c16df0a199a02222706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b509284ea760c16df0a199a02222706">compute</a> (const MatrixType &amp;matrix)</td></tr>
<tr class="memdesc:a5b509284ea760c16df0a199a02222706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze and factorize the matrix so the solver is ready to solve.  <br /></td></tr>
<tr class="separator:a5b509284ea760c16df0a199a02222706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccf9472f094f27f508a69526de44946" id="r_aeccf9472f094f27f508a69526de44946"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeccf9472f094f27f508a69526de44946">determinant</a> ()</td></tr>
<tr class="memdesc:aeccf9472f094f27f508a69526de44946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the determinant.  <br /></td></tr>
<tr class="separator:aeccf9472f094f27f508a69526de44946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39858b0e72f2659d596364e252b34cbc" id="r_a39858b0e72f2659d596364e252b34cbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39858b0e72f2659d596364e252b34cbc">factorize</a> (const MatrixType &amp;matrix)</td></tr>
<tr class="memdesc:a39858b0e72f2659d596364e252b34cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize the matrix to get the solver ready.  <br /></td></tr>
<tr class="separator:a39858b0e72f2659d596364e252b34cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619e12b0ec4a3e767c1e797162e23745" id="r_a619e12b0ec4a3e767c1e797162e23745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619e12b0ec4a3e767c1e797162e23745">info</a> () const</td></tr>
<tr class="memdesc:a619e12b0ec4a3e767c1e797162e23745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether previous computation was successful.  <br /></td></tr>
<tr class="separator:a619e12b0ec4a3e767c1e797162e23745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc74f4ce95a46895eb0195cce99ff4d7" id="r_adc74f4ce95a46895eb0195cce99ff4d7"><td class="memItemLeft" align="right" valign="top"><a id="adc74f4ce95a46895eb0195cce99ff4d7" name="adc74f4ce95a46895eb0195cce99ff4d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>isSymmetric</b> (bool sym)</td></tr>
<tr class="memdesc:adc74f4ce95a46895eb0195cce99ff4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let you set that the pattern of the input matrix is symmetric. <br /></td></tr>
<tr class="separator:adc74f4ce95a46895eb0195cce99ff4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4591a05dc1b025ea2704da6cd1b19dde" id="r_a4591a05dc1b025ea2704da6cd1b19dde"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4591a05dc1b025ea2704da6cd1b19dde">lastErrorMessage</a> () const</td></tr>
<tr class="memdesc:a4591a05dc1b025ea2704da6cd1b19dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a human readable error.  <br /></td></tr>
<tr class="separator:a4591a05dc1b025ea2704da6cd1b19dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b776be947c48a76d48f234fa6bf84da" id="r_a0b776be947c48a76d48f234fa6bf84da"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b776be947c48a76d48f234fa6bf84da">logAbsDeterminant</a> () const</td></tr>
<tr class="memdesc:a0b776be947c48a76d48f234fa6bf84da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the natural log of the absolute determinant.  <br /></td></tr>
<tr class="separator:a0b776be947c48a76d48f234fa6bf84da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddf76c949b3fe9b423a35f400de9827" id="r_a4ddf76c949b3fe9b423a35f400de9827"><td class="memItemLeft" align="right" valign="top">SparseLUMatrixLReturnType&lt; SCMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ddf76c949b3fe9b423a35f400de9827">matrixL</a> () const</td></tr>
<tr class="memdesc:a4ddf76c949b3fe9b423a35f400de9827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the matrixL.  <br /></td></tr>
<tr class="separator:a4ddf76c949b3fe9b423a35f400de9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a0d2667c27a919947bc6c2ba61afb9" id="r_a05a0d2667c27a919947bc6c2ba61afb9"><td class="memItemLeft" align="right" valign="top">SparseLUMatrixUReturnType&lt; SCMatrix, <a class="el" href="classEigen_1_1Map.html">Map</a>&lt; <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>, StorageIndex &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05a0d2667c27a919947bc6c2ba61afb9">matrixU</a> () const</td></tr>
<tr class="memdesc:a05a0d2667c27a919947bc6c2ba61afb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the MatrixU.  <br /></td></tr>
<tr class="separator:a05a0d2667c27a919947bc6c2ba61afb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00b855cfaabd0a35c84796000021630" id="r_ab00b855cfaabd0a35c84796000021630"><td class="memItemLeft" align="right" valign="top"><a id="ab00b855cfaabd0a35c84796000021630" name="ab00b855cfaabd0a35c84796000021630"></a>
<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nnzL</b> () const</td></tr>
<tr class="memdesc:ab00b855cfaabd0a35c84796000021630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the number of non zero in matrix L. <br /></td></tr>
<tr class="separator:ab00b855cfaabd0a35c84796000021630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ed6f6223b47422bb676e697451c162" id="r_a14ed6f6223b47422bb676e697451c162"><td class="memItemLeft" align="right" valign="top"><a id="a14ed6f6223b47422bb676e697451c162" name="a14ed6f6223b47422bb676e697451c162"></a>
<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nnzU</b> () const</td></tr>
<tr class="memdesc:a14ed6f6223b47422bb676e697451c162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the number of non zero in matrix U. <br /></td></tr>
<tr class="separator:a14ed6f6223b47422bb676e697451c162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1016d2b21d3230d6f4a77540b5110b85" id="r_a1016d2b21d3230d6f4a77540b5110b85"><td class="memItemLeft" align="right" valign="top"><a id="a1016d2b21d3230d6f4a77540b5110b85" name="a1016d2b21d3230d6f4a77540b5110b85"></a>
<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b> () const</td></tr>
<tr class="memdesc:a1016d2b21d3230d6f4a77540b5110b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the number of rows. <br /></td></tr>
<tr class="separator:a1016d2b21d3230d6f4a77540b5110b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15f3a4faf3cc42f09b444f4a57f1683" id="r_ac15f3a4faf3cc42f09b444f4a57f1683"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac15f3a4faf3cc42f09b444f4a57f1683">rowsPermutation</a> () const</td></tr>
<tr class="memdesc:ac15f3a4faf3cc42f09b444f4a57f1683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the row matrix permutation.  <br /></td></tr>
<tr class="separator:ac15f3a4faf3cc42f09b444f4a57f1683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab85d3c48ba0bdfea31754094f7233d" id="r_a0ab85d3c48ba0bdfea31754094f7233d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ab85d3c48ba0bdfea31754094f7233d">setPivotThreshold</a> (const RealScalar &amp;thresh)</td></tr>
<tr class="separator:a0ab85d3c48ba0bdfea31754094f7233d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e90fafa69e65e84c0f5fb76d6f39f8" id="r_a66e90fafa69e65e84c0f5fb76d6f39f8"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66e90fafa69e65e84c0f5fb76d6f39f8">signDeterminant</a> ()</td></tr>
<tr class="memdesc:a66e90fafa69e65e84c0f5fb76d6f39f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the sign of the determinant.  <br /></td></tr>
<tr class="separator:a66e90fafa69e65e84c0f5fb76d6f39f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a74a14996766dc6aba667590aa27b8" id="r_a08a74a14996766dc6aba667590aa27b8"><td class="memTemplParams" colspan="2">template&lt;typename Rhs &gt; </td></tr>
<tr class="memitem:a08a74a14996766dc6aba667590aa27b8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Solve.html">Solve</a>&lt; <a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a>, Rhs &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08a74a14996766dc6aba667590aa27b8">solve</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Rhs &gt; &amp;B) const</td></tr>
<tr class="memdesc:a08a74a14996766dc6aba667590aa27b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Solve.html" title="Pseudo expression representing a solving operation.">Solve</a> a system \( A X = B \).  <br /></td></tr>
<tr class="separator:a08a74a14996766dc6aba667590aa27b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fae39e74873e0792b137725ca225064" id="r_a7fae39e74873e0792b137725ca225064"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fae39e74873e0792b137725ca225064">SparseLU</a> ()</td></tr>
<tr class="memdesc:a7fae39e74873e0792b137725ca225064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic constructor of the solver.  <br /></td></tr>
<tr class="separator:a7fae39e74873e0792b137725ca225064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a97ebfe407d2c3597b71afefa266a1" id="r_ae5a97ebfe407d2c3597b71afefa266a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5a97ebfe407d2c3597b71afefa266a1">SparseLU</a> (const MatrixType &amp;matrix)</td></tr>
<tr class="memdesc:ae5a97ebfe407d2c3597b71afefa266a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the solver already based on a specific matrix.  <br /></td></tr>
<tr class="separator:ae5a97ebfe407d2c3597b71afefa266a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05e6d3b85dc27bd7ec0b3ef9380a9de" id="r_af05e6d3b85dc27bd7ec0b3ef9380a9de"><td class="memItemLeft" align="right" valign="top">const SparseLUTransposeView&lt; false, <a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a>&lt; MatrixType_, OrderingType_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af05e6d3b85dc27bd7ec0b3ef9380a9de">transpose</a> ()</td></tr>
<tr class="memdesc:af05e6d3b85dc27bd7ec0b3ef9380a9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a solver for the transposed matrix.  <br /></td></tr>
<tr class="separator:af05e6d3b85dc27bd7ec0b3ef9380a9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1SparseSolverBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classEigen_1_1SparseSolverBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1SparseSolverBase.html">Eigen::SparseSolverBase&lt; SparseLU&lt; MatrixType_, OrderingType_ &gt; &gt;</a></td></tr>
<tr class="memitem:a57c5b7f5e35274b55b5d57e8c88cc4a6 inherit pub_methods_classEigen_1_1SparseSolverBase" id="r_a57c5b7f5e35274b55b5d57e8c88cc4a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Solve.html">Solve</a>&lt; <a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;, Rhs &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseSolverBase.html#a57c5b7f5e35274b55b5d57e8c88cc4a6">solve</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Rhs &gt; &amp;b) const</td></tr>
<tr class="separator:a57c5b7f5e35274b55b5d57e8c88cc4a6 inherit pub_methods_classEigen_1_1SparseSolverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa525407e654603e8275cefeda32054c9 inherit pub_methods_classEigen_1_1SparseSolverBase" id="r_aa525407e654603e8275cefeda32054c9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Solve.html">Solve</a>&lt; <a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;, Rhs &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseSolverBase.html#aa525407e654603e8275cefeda32054c9">solve</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; Rhs &gt; &amp;b) const</td></tr>
<tr class="separator:aa525407e654603e8275cefeda32054c9 inherit pub_methods_classEigen_1_1SparseSolverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd99fa17db475e74d3834767f392f33 inherit pub_methods_classEigen_1_1SparseSolverBase" id="r_aacd99fa17db475e74d3834767f392f33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseSolverBase.html#aacd99fa17db475e74d3834767f392f33">SparseSolverBase</a> ()</td></tr>
<tr class="separator:aacd99fa17db475e74d3834767f392f33 inherit pub_methods_classEigen_1_1SparseSolverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7fae39e74873e0792b137725ca225064" name="a7fae39e74873e0792b137725ca225064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fae39e74873e0792b137725ca225064">&#9670;&#160;</a></span>SparseLU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::SparseLU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Basic constructor of the solver. </p>
<p>Construct a <a class="el" href="classEigen_1_1SparseLU.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a>. As no matrix is given as argument, <a class="el" href="#a5b509284ea760c16df0a199a02222706" title="Analyze and factorize the matrix so the solver is ready to solve.">compute()</a> should be called afterward with a matrix. </p>

</div>
</div>
<a id="ae5a97ebfe407d2c3597b71afefa266a1" name="ae5a97ebfe407d2c3597b71afefa266a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a97ebfe407d2c3597b71afefa266a1">&#9670;&#160;</a></span>SparseLU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::SparseLU </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the solver already based on a specific matrix. </p>
<p>Construct a <a class="el" href="classEigen_1_1SparseLU.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a>. <a class="el" href="#a5b509284ea760c16df0a199a02222706" title="Analyze and factorize the matrix so the solver is ready to solve.">compute()</a> is already called with the given matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9607aab8ecb951b12a80dce2c39f44e8" name="a9607aab8ecb951b12a80dce2c39f44e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9607aab8ecb951b12a80dce2c39f44e8">&#9670;&#160;</a></span>absDeterminant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::absDeterminant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the absolute value of the determinant. </p>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of the determinant of the matrix of which *this is the QR decomposition.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>a determinant can be very big or small, so for matrices of large enough dimension, there is a risk of overflow/underflow. One way to work around that is to use <a class="el" href="#a0b776be947c48a76d48f234fa6bf84da" title="Give the natural log of the absolute determinant.">logAbsDeterminant()</a> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0b776be947c48a76d48f234fa6bf84da" title="Give the natural log of the absolute determinant.">logAbsDeterminant()</a>, <a class="el" href="#a66e90fafa69e65e84c0f5fb76d6f39f8" title="Give the sign of the determinant.">signDeterminant()</a> </dd></dl>

</div>
</div>
<a id="a25dc8970973e010a7876398ab3f47332" name="a25dc8970973e010a7876398ab3f47332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dc8970973e010a7876398ab3f47332">&#9670;&#160;</a></span>adjoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SparseLUTransposeView&lt; true, <a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a>&lt; MatrixType_, OrderingType_ &gt; &gt; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::adjoint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a solver for the adjointed matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the adjoint of the factored matrix</dd></dl>
<p>A typical usage is to solve for the adjoint problem A' x = b: </p><div class="fragment"><div class="line">solver.compute(A);</div>
<div class="line">x = solver.adjoint().solve(b);</div>
</div><!-- fragment --><p>For real scalar types, this function is equivalent to <a class="el" href="#af05e6d3b85dc27bd7ec0b3ef9380a9de" title="Return a solver for the transposed matrix.">transpose()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af05e6d3b85dc27bd7ec0b3ef9380a9de" title="Return a solver for the transposed matrix.">transpose()</a>, <a class="el" href="#a08a74a14996766dc6aba667590aa27b8" title="Solve a system .">solve()</a> </dd></dl>

</div>
</div>
<a id="aa907ff958c4f4855145091d2686f3a8a" name="aa907ff958c4f4855145091d2686f3a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa907ff958c4f4855145091d2686f3a8a">&#9670;&#160;</a></span>analyzePattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename OrderingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType, OrderingType &gt;::analyzePattern </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the column permutation. </p>
<p>Compute the column permutation to minimize the fill-in</p>
<ul>
<li>Apply this permutation to the input matrix -</li>
<li>Compute the column elimination tree on the permuted matrix</li>
<li>Postorder the elimination tree and the column permutation</li>
</ul>
<p>It is possible to call <a class="el" href="#a5b509284ea760c16df0a199a02222706" title="Analyze and factorize the matrix so the solver is ready to solve.">compute()</a> instead of <a class="el" href="#aa907ff958c4f4855145091d2686f3a8a" title="Compute the column permutation.">analyzePattern()</a> + <a class="el" href="#a39858b0e72f2659d596364e252b34cbc" title="Factorize the matrix to get the solver ready.">factorize()</a>.</p>
<p>If the matrix is row-major this function will do an heavy copy.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a39858b0e72f2659d596364e252b34cbc" title="Factorize the matrix to get the solver ready.">factorize()</a>, <a class="el" href="#a5b509284ea760c16df0a199a02222706" title="Analyze and factorize the matrix so the solver is ready to solve.">compute()</a> </dd></dl>

</div>
</div>
<a id="a69fd18705475738bf1a950f9dfb0a49a" name="a69fd18705475738bf1a950f9dfb0a49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fd18705475738bf1a950f9dfb0a49a">&#9670;&#160;</a></span>colsPermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a> &amp; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::colsPermutation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the column matrix permutation. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the column matrix permutation \( P_c^T \) such that \(P_r A P_c^T = L U\) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac15f3a4faf3cc42f09b444f4a57f1683" title="Give the row matrix permutation.">rowsPermutation()</a> </dd></dl>

</div>
</div>
<a id="a5b509284ea760c16df0a199a02222706" name="a5b509284ea760c16df0a199a02222706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b509284ea760c16df0a199a02222706">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyze and factorize the matrix so the solver is ready to solve. </p>
<p>Compute the symbolic and numeric factorization of the input sparse matrix. The input matrix should be in column-major storage, otherwise <a class="el" href="#aa907ff958c4f4855145091d2686f3a8a" title="Compute the column permutation.">analyzePattern()</a> will do a heavy copy.</p>
<p>Call <a class="el" href="#aa907ff958c4f4855145091d2686f3a8a" title="Compute the column permutation.">analyzePattern()</a> followed by <a class="el" href="#a39858b0e72f2659d596364e252b34cbc" title="Factorize the matrix to get the solver ready.">factorize()</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa907ff958c4f4855145091d2686f3a8a" title="Compute the column permutation.">analyzePattern()</a>, <a class="el" href="#a39858b0e72f2659d596364e252b34cbc" title="Factorize the matrix to get the solver ready.">factorize()</a> </dd></dl>

</div>
</div>
<a id="aeccf9472f094f27f508a69526de44946" name="aeccf9472f094f27f508a69526de44946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccf9472f094f27f508a69526de44946">&#9670;&#160;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::determinant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the determinant. </p>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the matrix.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9607aab8ecb951b12a80dce2c39f44e8" title="Give the absolute value of the determinant.">absDeterminant()</a>, <a class="el" href="#a0b776be947c48a76d48f234fa6bf84da" title="Give the natural log of the absolute determinant.">logAbsDeterminant()</a> </dd></dl>

</div>
</div>
<a id="a39858b0e72f2659d596364e252b34cbc" name="a39858b0e72f2659d596364e252b34cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39858b0e72f2659d596364e252b34cbc">&#9670;&#160;</a></span>factorize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename OrderingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType, OrderingType &gt;::factorize </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factorize the matrix to get the solver ready. </p>
<ul>
<li>Numerical factorization</li>
<li>Interleaved with the symbolic factorization</li>
</ul>
<p>To get error of this function you should check <a class="el" href="#a619e12b0ec4a3e767c1e797162e23745" title="Reports whether previous computation was successful.">info()</a>, you can get more info of errors with <a class="el" href="#a4591a05dc1b025ea2704da6cd1b19dde" title="Give a human readable error.">lastErrorMessage()</a>.</p>
<p>In the past (before 2012 (git history is not older)), this function was returning an integer. This exit was 0 if successful factorization. </p><blockquote class="doxtable">
<p>&zwj;0 if info = i, and i is been completed, but the factor U is exactly singular, </p>
</blockquote>
<p>and division by zero will occur if it is used to solve a system of equation. </p><blockquote class="doxtable">
<p>&zwj;A-&gt;ncol: number of bytes allocated when memory allocation failure occurred, plus A-&gt;ncol. </p>
</blockquote>
<p>If lwork = -1, it is the estimated amount of space needed, plus A-&gt;ncol.</p>
<p>It seems that A was the name of the matrix in the past.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa907ff958c4f4855145091d2686f3a8a" title="Compute the column permutation.">analyzePattern()</a>, <a class="el" href="#a5b509284ea760c16df0a199a02222706" title="Analyze and factorize the matrix so the solver is ready to solve.">compute()</a>, <a class="el" href="#a7fae39e74873e0792b137725ca225064" title="Basic constructor of the solver.">SparseLU()</a>, <a class="el" href="#a619e12b0ec4a3e767c1e797162e23745" title="Reports whether previous computation was successful.">info()</a>, <a class="el" href="#a4591a05dc1b025ea2704da6cd1b19dde" title="Give a human readable error.">lastErrorMessage()</a> </dd></dl>

</div>
</div>
<a id="a619e12b0ec4a3e767c1e797162e23745" name="a619e12b0ec4a3e767c1e797162e23745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619e12b0ec4a3e767c1e797162e23745">&#9670;&#160;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::info </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports whether previous computation was successful. </p>
<dl class="section return"><dt>Returns</dt><dd><code>Success</code> if computation was successful, <code>NumericalIssue</code> if the LU factorization reports a problem, zero diagonal for instance <code>InvalidInput</code> if the input matrix is invalid</dd></dl>
<p>You can get a readable error message with <a class="el" href="#a4591a05dc1b025ea2704da6cd1b19dde" title="Give a human readable error.">lastErrorMessage()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4591a05dc1b025ea2704da6cd1b19dde" title="Give a human readable error.">lastErrorMessage()</a> </dd></dl>

</div>
</div>
<a id="a4591a05dc1b025ea2704da6cd1b19dde" name="a4591a05dc1b025ea2704da6cd1b19dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4591a05dc1b025ea2704da6cd1b19dde">&#9670;&#160;</a></span>lastErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::lastErrorMessage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give a human readable error. </p>
<dl class="section return"><dt>Returns</dt><dd>A string describing the type of error </dd></dl>

</div>
</div>
<a id="a0b776be947c48a76d48f234fa6bf84da" name="a0b776be947c48a76d48f234fa6bf84da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b776be947c48a76d48f234fa6bf84da">&#9670;&#160;</a></span>logAbsDeterminant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::logAbsDeterminant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the natural log of the absolute determinant. </p>
<dl class="section return"><dt>Returns</dt><dd>the natural log of the absolute value of the determinant of the matrix of which **this is the QR decomposition</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is useful to work around the risk of overflow/underflow that's inherent to the determinant computation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9607aab8ecb951b12a80dce2c39f44e8" title="Give the absolute value of the determinant.">absDeterminant()</a>, <a class="el" href="#a66e90fafa69e65e84c0f5fb76d6f39f8" title="Give the sign of the determinant.">signDeterminant()</a> </dd></dl>

</div>
</div>
<a id="a4ddf76c949b3fe9b423a35f400de9827" name="a4ddf76c949b3fe9b423a35f400de9827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddf76c949b3fe9b423a35f400de9827">&#9670;&#160;</a></span>matrixL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparseLUMatrixLReturnType&lt; SCMatrix &gt; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::matrixL </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the matrixL. </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix L, internally stored as supernodes The only operation available with this expression is the triangular solve <div class="fragment"><div class="line">y = b; <a class="code hl_function" href="#a4ddf76c949b3fe9b423a35f400de9827">matrixL</a>().solveInPlace(y);</div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_a4ddf76c949b3fe9b423a35f400de9827"><div class="ttname"><a href="#a4ddf76c949b3fe9b423a35f400de9827">Eigen::SparseLU::matrixL</a></div><div class="ttdeci">SparseLUMatrixLReturnType&lt; SCMatrix &gt; matrixL() const</div><div class="ttdoc">Give the matrixL.</div><div class="ttdef"><b>Definition</b> SparseLU.h:275</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a05a0d2667c27a919947bc6c2ba61afb9" name="a05a0d2667c27a919947bc6c2ba61afb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a0d2667c27a919947bc6c2ba61afb9">&#9670;&#160;</a></span>matrixU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparseLUMatrixUReturnType&lt; SCMatrix, <a class="el" href="classEigen_1_1Map.html">Map</a>&lt; <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>, StorageIndex &gt; &gt; &gt; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::matrixU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the MatrixU. </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix U, The only operation available with this expression is the triangular solve <div class="fragment"><div class="line">y = b; <a class="code hl_function" href="#a05a0d2667c27a919947bc6c2ba61afb9">matrixU</a>().solveInPlace(y);</div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_a05a0d2667c27a919947bc6c2ba61afb9"><div class="ttname"><a href="#a05a0d2667c27a919947bc6c2ba61afb9">Eigen::SparseLU::matrixU</a></div><div class="ttdeci">SparseLUMatrixUReturnType&lt; SCMatrix, Map&lt; SparseMatrix&lt; Scalar, ColMajor, StorageIndex &gt; &gt; &gt; matrixU() const</div><div class="ttdoc">Give the MatrixU.</div><div class="ttdef"><b>Definition</b> SparseLU.h:284</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac15f3a4faf3cc42f09b444f4a57f1683" name="ac15f3a4faf3cc42f09b444f4a57f1683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15f3a4faf3cc42f09b444f4a57f1683">&#9670;&#160;</a></span>rowsPermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a> &amp; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::rowsPermutation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the row matrix permutation. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the row matrix permutation \( P_r \) such that \(P_r A P_c^T = L U\) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a69fd18705475738bf1a950f9dfb0a49a" title="Give the column matrix permutation.">colsPermutation()</a> </dd></dl>

</div>
</div>
<a id="a0ab85d3c48ba0bdfea31754094f7233d" name="a0ab85d3c48ba0bdfea31754094f7233d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab85d3c48ba0bdfea31754094f7233d">&#9670;&#160;</a></span>setPivotThreshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::setPivotThreshold </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;</td>          <td class="paramname"><span class="paramname"><em>thresh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the threshold used for a diagonal entry to be an acceptable pivot. </p>

</div>
</div>
<a id="a66e90fafa69e65e84c0f5fb76d6f39f8" name="a66e90fafa69e65e84c0f5fb76d6f39f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e90fafa69e65e84c0f5fb76d6f39f8">&#9670;&#160;</a></span>signDeterminant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::signDeterminant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the sign of the determinant. </p>
<dl class="section return"><dt>Returns</dt><dd>A number representing the sign of the determinant</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9607aab8ecb951b12a80dce2c39f44e8" title="Give the absolute value of the determinant.">absDeterminant()</a>, <a class="el" href="#a0b776be947c48a76d48f234fa6bf84da" title="Give the natural log of the absolute determinant.">logAbsDeterminant()</a> </dd></dl>

</div>
</div>
<a id="a08a74a14996766dc6aba667590aa27b8" name="a08a74a14996766dc6aba667590aa27b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a74a14996766dc6aba667590aa27b8">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<div class="memtemplate">
template&lt;typename Rhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Solve.html">Solve</a>&lt; <a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a>, Rhs &gt; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Rhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classEigen_1_1Solve.html" title="Pseudo expression representing a solving operation.">Solve</a> a system \( A X = B \). </p>
<dl class="section return"><dt>Returns</dt><dd>the solution X of \( A X = B \) using the current decomposition of A.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the destination matrix X in X = this-&gt;solve(B) must be colmun-major.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5b509284ea760c16df0a199a02222706" title="Analyze and factorize the matrix so the solver is ready to solve.">compute()</a> </dd></dl>

</div>
</div>
<a id="af05e6d3b85dc27bd7ec0b3ef9380a9de" name="af05e6d3b85dc27bd7ec0b3ef9380a9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05e6d3b85dc27bd7ec0b3ef9380a9de">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType_ , typename OrderingType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SparseLUTransposeView&lt; false, <a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a>&lt; MatrixType_, OrderingType_ &gt; &gt; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType_, OrderingType_ &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a solver for the transposed matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the transposed of the factored matrix.</dd></dl>
<p>A typical usage is to solve for the transposed problem A^T x = b: </p><div class="fragment"><div class="line">solver.compute(A);</div>
<div class="line">x = solver.transpose().solve(b);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a25dc8970973e010a7876398ab3f47332" title="Return a solver for the adjointed matrix.">adjoint()</a>, <a class="el" href="#a08a74a14996766dc6aba667590aa27b8" title="Solve a system .">solve()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SparseLU_8h_source.html">SparseLU.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a></li>
    <li class="footer">Generated on Mon Sep 23 2024 01:14:47 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
