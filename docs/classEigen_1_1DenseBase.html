<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Eigen::DenseBase&lt; Derived &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.4.90 (git rev 2d4c9b400cca33d2f5cf316efc7151236244edb1)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classEigen_1_1DenseBase.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="classEigen_1_1DenseBase-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Symbols</a>  </div>
  <div class="headertitle"><div class="title">Eigen::DenseBase&lt; Derived &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__DenseMatrixManipulation__chapter.html">Dense matrix and array manipulation</a> &raquo; <a class="el" href="group__DenseMatrixManipulation__Reference.html">Reference</a> &raquo; <a class="el" href="group__Core__Module.html">Core module</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Derived&gt;<br />
class Eigen::DenseBase&lt; Derived &gt;</div><p>Base class for all dense matrices, vectors, and arrays. </p>
<p>This class is the base that is inherited by all dense objects (matrix, vector, arrays, and related expression types). The common <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> API for dense objects is contained in this class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>is the derived type, e.g., a matrix type or an expression.</td></tr>
  </table>
  </dd>
</dl>
<p>This class can be extended with the help of the plugin mechanism described on the page <a class="el" href="TopicCustomizing_Plugins.html">Extending MatrixBase (and other classes)</a> by defining the preprocessor symbol <code>EIGEN_DENSEBASE_PLUGIN</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="TopicClassHierarchy.html">The class hierarchy</a> </dd></dl>
</div><div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Eigen::DenseBase&lt; Derived &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classEigen_1_1DenseBase__inherit__graph.png" border="0" usemap="#aEigen_1_1DenseBase_3_01Derived_01_4_inherit__map" alt="Inheritance graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad65279b1533923e9a69ce51c7950e9f0" id="r_ad65279b1533923e9a69ce51c7950e9f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>
, <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>
, <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>
, <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0ad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>
, <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0acc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a>
, <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a3a459062d39cb34452518f5f201161d2">MaxSizeAtCompileTime</a>
, <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a1156955c8099c5072934b74c72654ed0">IsVectorAtCompileTime</a>
, <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a4d4548a01ba37a6c2031a3c1f0a37d34">NumDimensions</a>
, <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a7392c9b2ad41ba3c16fdc5306c04d581">Flags</a>
, <br />
&#160;&#160;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a>
, <br />
&#160;&#160;<b>InnerSizeAtCompileTime</b>
, <br />
&#160;&#160;<b>InnerStrideAtCompileTime</b>
, <br />
&#160;&#160;<b>OuterStrideAtCompileTime</b>
<br />
 }</td></tr>
<tr class="separator:ad65279b1533923e9a69ce51c7950e9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d9418d4b34874e9005d961c490cd2" id="r_a306d9418d4b34874e9005d961c490cd2"><td class="memItemLeft" align="right" valign="top">typedef random_access_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a306d9418d4b34874e9005d961c490cd2">const_iterator</a></td></tr>
<tr class="separator:a306d9418d4b34874e9005d961c490cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5130902770642a1a057a99c397d357d" id="r_af5130902770642a1a057a99c397d357d"><td class="memItemLeft" align="right" valign="top">typedef random_access_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5130902770642a1a057a99c397d357d">iterator</a></td></tr>
<tr class="separator:af5130902770642a1a057a99c397d357d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e3075eb0c3841a7badabd08c4860d1" id="r_a84e3075eb0c3841a7badabd08c4860d1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Array.html">Array</a>&lt; typename internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a>|(internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a7392c9b2ad41ba3c16fdc5306c04d581">::Flags</a> &amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> :<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0ad2baadea085372837b0e80dc93be1306">::MaxRowsAtCompileTime</a>, internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0acc3a41000cf1d29dd1a320b2a09d2a65">::MaxColsAtCompileTime</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e3075eb0c3841a7badabd08c4860d1">PlainArray</a></td></tr>
<tr class="separator:a84e3075eb0c3841a7badabd08c4860d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c5c57adb01354a7f0e67d5579c2926" id="r_a41c5c57adb01354a7f0e67d5579c2926"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; typename internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a>|(internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a7392c9b2ad41ba3c16fdc5306c04d581">::Flags</a> &amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> :<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0ad2baadea085372837b0e80dc93be1306">::MaxRowsAtCompileTime</a>, internal::traits&lt; Derived &gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0acc3a41000cf1d29dd1a320b2a09d2a65">::MaxColsAtCompileTime</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41c5c57adb01354a7f0e67d5579c2926">PlainMatrix</a></td></tr>
<tr class="separator:a41c5c57adb01354a7f0e67d5579c2926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f82d9f5a1367f64b9a61df53b836d4" id="r_a25f82d9f5a1367f64b9a61df53b836d4"><td class="memItemLeft" align="right" valign="top">typedef std::conditional_t&lt; internal::is_same&lt; typename internal::traits&lt; Derived &gt;::XprKind, <a class="el" href="structEigen_1_1MatrixXpr.html">MatrixXpr</a> &gt;<a class="el" href="#a8515f719046aa4851e385661f45595b0">::value</a>, <a class="el" href="#a41c5c57adb01354a7f0e67d5579c2926">PlainMatrix</a>, <a class="el" href="#a84e3075eb0c3841a7badabd08c4860d1">PlainArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25f82d9f5a1367f64b9a61df53b836d4">PlainObject</a></td></tr>
<tr class="memdesc:a25f82d9f5a1367f64b9a61df53b836d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plain matrix or array type corresponding to this expression.  <br /></td></tr>
<tr class="separator:a25f82d9f5a1367f64b9a61df53b836d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feed465b3a8e60c47e73ecce83e39a2" id="r_a5feed465b3a8e60c47e73ecce83e39a2"><td class="memItemLeft" align="right" valign="top">typedef internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a></td></tr>
<tr class="separator:a5feed465b3a8e60c47e73ecce83e39a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1aba3f6c414715d830f760913c7e00" id="r_a2d1aba3f6c414715d830f760913c7e00"><td class="memItemLeft" align="right" valign="top">typedef internal::traits&lt; Derived &gt;::StorageIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d1aba3f6c414715d830f760913c7e00">StorageIndex</a></td></tr>
<tr class="memdesc:a2d1aba3f6c414715d830f760913c7e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to store indices.  <br /></td></tr>
<tr class="separator:a2d1aba3f6c414715d830f760913c7e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9276182dab8236c33f1e7abf491d504d" id="r_a9276182dab8236c33f1e7abf491d504d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9276182dab8236c33f1e7abf491d504d">value_type</a></td></tr>
<tr class="separator:a9276182dab8236c33f1e7abf491d504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structEigen_1_1EigenBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_structEigen_1_1EigenBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structEigen_1_1EigenBase.html">Eigen::EigenBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase" id="r_a554f30542cc2316add4b1ea0a492ff02"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a></td></tr>
<tr class="memdesc:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface type of indices.  <br /></td></tr>
<tr class="separator:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae42ab60296c120e9f45ce3b44e1761a4" id="r_ae42ab60296c120e9f45ce3b44e1761a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae42ab60296c120e9f45ce3b44e1761a4">all</a> () const</td></tr>
<tr class="separator:ae42ab60296c120e9f45ce3b44e1761a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e669fd3aaae50a4870dc1b8f3b8884" id="r_af1e669fd3aaae50a4870dc1b8f3b8884"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1e669fd3aaae50a4870dc1b8f3b8884">allFinite</a> () const</td></tr>
<tr class="separator:af1e669fd3aaae50a4870dc1b8f3b8884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbf4cb72dd577e62fbe035b1c53e695" id="r_abfbf4cb72dd577e62fbe035b1c53e695"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfbf4cb72dd577e62fbe035b1c53e695">any</a> () const</td></tr>
<tr class="separator:abfbf4cb72dd577e62fbe035b1c53e695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57591454af931f9dffa71c9da28d5641" id="r_a57591454af931f9dffa71c9da28d5641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af5130902770642a1a057a99c397d357d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin</a> ()</td></tr>
<tr class="separator:a57591454af931f9dffa71c9da28d5641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9368ce70b06167ec5fc19398d329f5e" id="r_ad9368ce70b06167ec5fc19398d329f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a306d9418d4b34874e9005d961c490cd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9368ce70b06167ec5fc19398d329f5e">begin</a> () const</td></tr>
<tr class="separator:ad9368ce70b06167ec5fc19398d329f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a3dfd9b826ba3103de0128576fb15b" id="r_ae9a3dfd9b826ba3103de0128576fb15b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a306d9418d4b34874e9005d961c490cd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9a3dfd9b826ba3103de0128576fb15b">cbegin</a> () const</td></tr>
<tr class="separator:ae9a3dfd9b826ba3103de0128576fb15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3b76f02986c2af2521d07164b5ffde" id="r_aeb3b76f02986c2af2521d07164b5ffde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a306d9418d4b34874e9005d961c490cd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb3b76f02986c2af2521d07164b5ffde">cend</a> () const</td></tr>
<tr class="separator:aeb3b76f02986c2af2521d07164b5ffde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0e1b6067ec1de6cb8799da55aa7d30" id="r_a1c0e1b6067ec1de6cb8799da55aa7d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">ColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c0e1b6067ec1de6cb8799da55aa7d30">colwise</a> ()</td></tr>
<tr class="separator:a1c0e1b6067ec1de6cb8799da55aa7d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58837c81de446efbdb58da07b73a63c1" id="r_a58837c81de446efbdb58da07b73a63c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">ConstColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58837c81de446efbdb58da07b73a63c1">colwise</a> () const</td></tr>
<tr class="separator:a58837c81de446efbdb58da07b73a63c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab778f1c907d15d20fcc23f32ab102172" id="r_ab778f1c907d15d20fcc23f32ab102172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab778f1c907d15d20fcc23f32ab102172">count</a> () const</td></tr>
<tr class="separator:ab778f1c907d15d20fcc23f32ab102172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71d079e16d91360d10066b316b48485" id="r_ae71d079e16d91360d10066b316b48485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af5130902770642a1a057a99c397d357d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae71d079e16d91360d10066b316b48485">end</a> ()</td></tr>
<tr class="separator:ae71d079e16d91360d10066b316b48485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34773522e43bfb02e9cf652d7b5dd60" id="r_ab34773522e43bfb02e9cf652d7b5dd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a306d9418d4b34874e9005d961c490cd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab34773522e43bfb02e9cf652d7b5dd60">end</a> () const</td></tr>
<tr class="separator:ab34773522e43bfb02e9cf652d7b5dd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e57a2f0f7cfcb4ad4d55ea0b6414b" id="r_aa73e57a2f0f7cfcb4ad4d55ea0b6414b"><td class="memItemLeft" align="right" valign="top">EvalReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval</a> () const</td></tr>
<tr class="separator:aa73e57a2f0f7cfcb4ad4d55ea0b6414b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be169c308801411aa24be93d30930bf" id="r_a9be169c308801411aa24be93d30930bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9be169c308801411aa24be93d30930bf">fill</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:a9be169c308801411aa24be93d30930bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2db4b4596edd1bf7e1c43ac2d306047" id="r_ae2db4b4596edd1bf7e1c43ac2d306047"><td class="memTemplParams" colspan="2">template&lt;unsigned int Added, unsigned int Removed&gt; </td></tr>
<tr class="memitem:ae2db4b4596edd1bf7e1c43ac2d306047"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEPRECATED const Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2db4b4596edd1bf7e1c43ac2d306047">flagged</a> () const</td></tr>
<tr class="separator:ae2db4b4596edd1bf7e1c43ac2d306047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148e20e32aa3ceca13e0a49c2cc584fc" id="r_a148e20e32aa3ceca13e0a49c2cc584fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a148e20e32aa3ceca13e0a49c2cc584fc">format</a> (const <a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a> &amp;fmt) const</td></tr>
<tr class="separator:a148e20e32aa3ceca13e0a49c2cc584fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ca41d9635a8ab3c5a268ef3f7f0d75" id="r_a58ca41d9635a8ab3c5a268ef3f7f0d75"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58ca41d9635a8ab3c5a268ef3f7f0d75">innerSize</a> () const</td></tr>
<tr class="separator:a58ca41d9635a8ab3c5a268ef3f7f0d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8443357b808cd393be1b51974213f9c" id="r_ae8443357b808cd393be1b51974213f9c"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ae8443357b808cd393be1b51974213f9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8443357b808cd393be1b51974213f9c">isApprox</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:ae8443357b808cd393be1b51974213f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b150d48bc5e4366887ccb466e40c6b" id="r_af9b150d48bc5e4366887ccb466e40c6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9b150d48bc5e4366887ccb466e40c6b">isApproxToConstant</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8515f719046aa4851e385661f45595b0">value</a>, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:af9b150d48bc5e4366887ccb466e40c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca84e4179b3e5081ed11d89bbd9e74f" id="r_a1ca84e4179b3e5081ed11d89bbd9e74f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ca84e4179b3e5081ed11d89bbd9e74f">isConstant</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8515f719046aa4851e385661f45595b0">value</a>, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a1ca84e4179b3e5081ed11d89bbd9e74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4db0c6dd974fa88bbb58b2cf3d5664" id="r_a3c4db0c6dd974fa88bbb58b2cf3d5664"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3c4db0c6dd974fa88bbb58b2cf3d5664"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c4db0c6dd974fa88bbb58b2cf3d5664">isMuchSmallerThan</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a3c4db0c6dd974fa88bbb58b2cf3d5664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfca6ff4e473f68fbbeabbd03b7504a9" id="r_adfca6ff4e473f68fbbeabbd03b7504a9"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:adfca6ff4e473f68fbbeabbd03b7504a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfca6ff4e473f68fbbeabbd03b7504a9">isMuchSmallerThan</a> (const typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real &amp;other, const RealScalar &amp;prec) const</td></tr>
<tr class="separator:adfca6ff4e473f68fbbeabbd03b7504a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56d6b4477cd3c92a9cf42f4b96e47c2" id="r_aa56d6b4477cd3c92a9cf42f4b96e47c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa56d6b4477cd3c92a9cf42f4b96e47c2">isOnes</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:aa56d6b4477cd3c92a9cf42f4b96e47c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36014ec300f53a65083057ed4e89822" id="r_af36014ec300f53a65083057ed4e89822"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af36014ec300f53a65083057ed4e89822">isZero</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:af36014ec300f53a65083057ed4e89822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1867382668870ff240913bed8aedd71" id="r_af1867382668870ff240913bed8aedd71"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af1867382668870ff240913bed8aedd71"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEPRECATED Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1867382668870ff240913bed8aedd71">lazyAssign</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:af1867382668870ff240913bed8aedd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6987d106f1cca3ac6ab36d288cc8e1" id="r_a7e6987d106f1cca3ac6ab36d288cc8e1"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation&gt; </td></tr>
<tr class="memitem:a7e6987d106f1cca3ac6ab36d288cc8e1"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e6987d106f1cca3ac6ab36d288cc8e1">maxCoeff</a> () const</td></tr>
<tr class="separator:a7e6987d106f1cca3ac6ab36d288cc8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced8ffda52ff061b6586ace2657ebf30" id="r_aced8ffda52ff061b6586ace2657ebf30"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation, typename IndexType &gt; </td></tr>
<tr class="memitem:aced8ffda52ff061b6586ace2657ebf30"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aced8ffda52ff061b6586ace2657ebf30">maxCoeff</a> (IndexType *index) const</td></tr>
<tr class="separator:aced8ffda52ff061b6586ace2657ebf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3780b7a9cd184d0b4f3ea797eba9e2b3" id="r_a3780b7a9cd184d0b4f3ea797eba9e2b3"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation, typename IndexType &gt; </td></tr>
<tr class="memitem:a3780b7a9cd184d0b4f3ea797eba9e2b3"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3780b7a9cd184d0b4f3ea797eba9e2b3">maxCoeff</a> (IndexType *row, IndexType *col) const</td></tr>
<tr class="separator:a3780b7a9cd184d0b4f3ea797eba9e2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ac6c0419a72ad7a88ea0bc189017d7" id="r_a21ac6c0419a72ad7a88ea0bc189017d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21ac6c0419a72ad7a88ea0bc189017d7">mean</a> () const</td></tr>
<tr class="separator:a21ac6c0419a72ad7a88ea0bc189017d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0739f9c868c331031c7810e21838dcb2" id="r_a0739f9c868c331031c7810e21838dcb2"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation&gt; </td></tr>
<tr class="memitem:a0739f9c868c331031c7810e21838dcb2"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0739f9c868c331031c7810e21838dcb2">minCoeff</a> () const</td></tr>
<tr class="separator:a0739f9c868c331031c7810e21838dcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9265f4f91430b9cc75d63fb6865bb29" id="r_ac9265f4f91430b9cc75d63fb6865bb29"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation, typename IndexType &gt; </td></tr>
<tr class="memitem:ac9265f4f91430b9cc75d63fb6865bb29"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac9265f4f91430b9cc75d63fb6865bb29">minCoeff</a> (IndexType *index) const</td></tr>
<tr class="separator:ac9265f4f91430b9cc75d63fb6865bb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28152ba4a42b2d112e5fec5469ec4c1" id="r_aa28152ba4a42b2d112e5fec5469ec4c1"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation, typename IndexType &gt; </td></tr>
<tr class="memitem:aa28152ba4a42b2d112e5fec5469ec4c1"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa28152ba4a42b2d112e5fec5469ec4c1">minCoeff</a> (IndexType *row, IndexType *col) const</td></tr>
<tr class="separator:aa28152ba4a42b2d112e5fec5469ec4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2761e2b6da74dba1d17b40cc918bf7" id="r_a3e2761e2b6da74dba1d17b40cc918bf7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e2761e2b6da74dba1d17b40cc918bf7">nestByValue</a> () const</td></tr>
<tr class="separator:a3e2761e2b6da74dba1d17b40cc918bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0e34696162b34762b2bf4bd948f90c" id="r_a0f0e34696162b34762b2bf4bd948f90c"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a0f0e34696162b34762b2bf4bd948f90c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f0e34696162b34762b2bf4bd948f90c">operator&lt;&lt;</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a0f0e34696162b34762b2bf4bd948f90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e575eb0ba6cc6bc5f347872abd8509d" id="r_a0e575eb0ba6cc6bc5f347872abd8509d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e575eb0ba6cc6bc5f347872abd8509d">operator&lt;&lt;</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;s)</td></tr>
<tr class="separator:a0e575eb0ba6cc6bc5f347872abd8509d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5281dadff89f46eef719b38e5d073a8f" id="r_a5281dadff89f46eef719b38e5d073a8f"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5281dadff89f46eef719b38e5d073a8f">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a> &amp;other)</td></tr>
<tr class="separator:a5281dadff89f46eef719b38e5d073a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66155169d20c035e80d521a8b918e97" id="r_ab66155169d20c035e80d521a8b918e97"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ab66155169d20c035e80d521a8b918e97"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab66155169d20c035e80d521a8b918e97">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:ab66155169d20c035e80d521a8b918e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58915510693d64164e567bd762e1032f" id="r_a58915510693d64164e567bd762e1032f"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a58915510693d64164e567bd762e1032f"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58915510693d64164e567bd762e1032f">operator=</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a58915510693d64164e567bd762e1032f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the generic expression <em>other</em> into *this.  <br /></td></tr>
<tr class="separator:a58915510693d64164e567bd762e1032f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f71699bc26ca2ee4e42ec4538862d7" id="r_a03f71699bc26ca2ee4e42ec4538862d7"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03f71699bc26ca2ee4e42ec4538862d7">outerSize</a> () const</td></tr>
<tr class="separator:a03f71699bc26ca2ee4e42ec4538862d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af119d9a4efe5a15cd83c1ccdf01b3a4f" id="r_af119d9a4efe5a15cd83c1ccdf01b3a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af119d9a4efe5a15cd83c1ccdf01b3a4f">prod</a> () const</td></tr>
<tr class="separator:af119d9a4efe5a15cd83c1ccdf01b3a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ab5a8020dcd9d5986cb20d8a7ab213" id="r_ad2ab5a8020dcd9d5986cb20d8a7ab213"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ad2ab5a8020dcd9d5986cb20d8a7ab213"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2ab5a8020dcd9d5986cb20d8a7ab213">redux</a> (const Func &amp;func) const</td></tr>
<tr class="separator:ad2ab5a8020dcd9d5986cb20d8a7ab213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dadfe80b813d808e91e4521c722a8e" id="r_a60dadfe80b813d808e91e4521c722a8e"><td class="memTemplParams" colspan="2">template&lt;int RowFactor, int ColFactor&gt; </td></tr>
<tr class="memitem:a60dadfe80b813d808e91e4521c722a8e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, RowFactor, ColFactor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60dadfe80b813d808e91e4521c722a8e">replicate</a> () const</td></tr>
<tr class="separator:a60dadfe80b813d808e91e4521c722a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b725f6109e29a759d623febe56ecd" id="r_a791b725f6109e29a759d623febe56ecd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791b725f6109e29a759d623febe56ecd">replicate</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rowFactor, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> colFactor) const</td></tr>
<tr class="separator:a791b725f6109e29a759d623febe56ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec5bac4e1ab95808808ef50ccf4cb39" id="r_a2ec5bac4e1ab95808808ef50ccf4cb39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ec5bac4e1ab95808808ef50ccf4cb39">resize</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> newSize)</td></tr>
<tr class="separator:a2ec5bac4e1ab95808808ef50ccf4cb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e2b4887b47b1f2346857d1931efa0f" id="r_a25e2b4887b47b1f2346857d1931efa0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25e2b4887b47b1f2346857d1931efa0f">resize</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a2d768a9877f5f69f49432d447b552bfe">cols</a>)</td></tr>
<tr class="separator:a25e2b4887b47b1f2346857d1931efa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ea394036d8b096abf322469c80198f" id="r_a38ea394036d8b096abf322469c80198f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38ea394036d8b096abf322469c80198f">reverse</a> ()</td></tr>
<tr class="separator:a38ea394036d8b096abf322469c80198f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2f3ac4019184abf95ca0e1a8d82866" id="r_a9e2f3ac4019184abf95ca0e1a8d82866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e2f3ac4019184abf95ca0e1a8d82866">reverse</a> () const</td></tr>
<tr class="separator:a9e2f3ac4019184abf95ca0e1a8d82866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8045155ea45f7961fc2a5170e1d921" id="r_adb8045155ea45f7961fc2a5170e1d921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb8045155ea45f7961fc2a5170e1d921">reverseInPlace</a> ()</td></tr>
<tr class="separator:adb8045155ea45f7961fc2a5170e1d921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daa3a3156ca0e0722bf78638e1c7f28" id="r_a6daa3a3156ca0e0722bf78638e1c7f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">RowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6daa3a3156ca0e0722bf78638e1c7f28">rowwise</a> ()</td></tr>
<tr class="separator:a6daa3a3156ca0e0722bf78638e1c7f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cabd3404528fe8cec4bab43d74bffc" id="r_aa1cabd3404528fe8cec4bab43d74bffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">ConstRowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1cabd3404528fe8cec4bab43d74bffc">rowwise</a> () const</td></tr>
<tr class="separator:aa1cabd3404528fe8cec4bab43d74bffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae565bdc9af5d0d7d6f86eeceefa0041f" id="r_ae565bdc9af5d0d7d6f86eeceefa0041f"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived , typename ElseDerived &gt; </td></tr>
<tr class="memitem:ae565bdc9af5d0d7d6f86eeceefa0041f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseTernaryOp.html">CwiseTernaryOp</a>&lt; internal::scalar_boolean_select_op&lt; typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &gt;, ThenDerived, ElseDerived, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae565bdc9af5d0d7d6f86eeceefa0041f">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const</td></tr>
<tr class="separator:ae565bdc9af5d0d7d6f86eeceefa0041f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f6127ef2e8edf0603624df9181f0d5" id="r_af1f6127ef2e8edf0603624df9181f0d5"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived &gt; </td></tr>
<tr class="memitem:af1f6127ef2e8edf0603624df9181f0d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseTernaryOp.html">CwiseTernaryOp</a>&lt; internal::scalar_boolean_select_op&lt; typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &gt;, ThenDerived, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;::ConstantReturnType, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1f6127ef2e8edf0603624df9181f0d5">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &amp;elseScalar) const</td></tr>
<tr class="separator:af1f6127ef2e8edf0603624df9181f0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9032b8ef4c81be6b61a89beaff1fa248" id="r_a9032b8ef4c81be6b61a89beaff1fa248"><td class="memTemplParams" colspan="2">template&lt;typename ElseDerived &gt; </td></tr>
<tr class="memitem:a9032b8ef4c81be6b61a89beaff1fa248"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseTernaryOp.html">CwiseTernaryOp</a>&lt; internal::scalar_boolean_select_op&lt; typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &gt;, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;::ConstantReturnType, ElseDerived, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9032b8ef4c81be6b61a89beaff1fa248">select</a> (const typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &amp;thenScalar, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const</td></tr>
<tr class="separator:a9032b8ef4c81be6b61a89beaff1fa248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f1e50d1f567da38da1d2f07c5ab559" id="r_ac2f1e50d1f567da38da1d2f07c5ab559"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2f1e50d1f567da38da1d2f07c5ab559">setConstant</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:ac2f1e50d1f567da38da1d2f07c5ab559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb023532476d3f14c457367e0eb5f3f1" id="r_aeb023532476d3f14c457367e0eb5f3f1"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb023532476d3f14c457367e0eb5f3f1">setLinSpaced</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:aeb023532476d3f14c457367e0eb5f3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <br /></td></tr>
<tr class="separator:aeb023532476d3f14c457367e0eb5f3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1ce9e801fa502e02b9b8cd9141ad0a" id="r_a5d1ce9e801fa502e02b9b8cd9141ad0a"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d1ce9e801fa502e02b9b8cd9141ad0a">setLinSpaced</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a>, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:a5d1ce9e801fa502e02b9b8cd9141ad0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <br /></td></tr>
<tr class="separator:a5d1ce9e801fa502e02b9b8cd9141ad0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250ef1b827e748f3f898fb2e55cb96e2" id="r_a250ef1b827e748f3f898fb2e55cb96e2"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a250ef1b827e748f3f898fb2e55cb96e2">setOnes</a> ()</td></tr>
<tr class="separator:a250ef1b827e748f3f898fb2e55cb96e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476e5852129ba32beaa1a8a3d7ee0db" id="r_ac476e5852129ba32beaa1a8a3d7ee0db"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac476e5852129ba32beaa1a8a3d7ee0db">setRandom</a> ()</td></tr>
<tr class="separator:ac476e5852129ba32beaa1a8a3d7ee0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af230a143de50695d2d1fae93db7e4dcb" id="r_af230a143de50695d2d1fae93db7e4dcb"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af230a143de50695d2d1fae93db7e4dcb">setZero</a> ()</td></tr>
<tr class="separator:af230a143de50695d2d1fae93db7e4dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd7080d5c202795820e361768d0140c" id="r_addd7080d5c202795820e361768d0140c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addd7080d5c202795820e361768d0140c">sum</a> () const</td></tr>
<tr class="separator:addd7080d5c202795820e361768d0140c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e7e4305fdb7781f2b2f05fa801f21e" id="r_af9e7e4305fdb7781f2b2f05fa801f21e"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af9e7e4305fdb7781f2b2f05fa801f21e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9e7e4305fdb7781f2b2f05fa801f21e">swap</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:af9e7e4305fdb7781f2b2f05fa801f21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e25adc6da9cd1d79f4c5bd7c1819cb" id="r_a44e25adc6da9cd1d79f4c5bd7c1819cb"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a44e25adc6da9cd1d79f4c5bd7c1819cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44e25adc6da9cd1d79f4c5bd7c1819cb">swap</a> (<a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a44e25adc6da9cd1d79f4c5bd7c1819cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cbcd866a0737eb56642c2e992f0afd" id="r_a43cbcd866a0737eb56642c2e992f0afd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Transpose.html">TransposeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose</a> ()</td></tr>
<tr class="separator:a43cbcd866a0737eb56642c2e992f0afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59eb71a8633da26de5e3e03351b2291e" id="r_a59eb71a8633da26de5e3e03351b2291e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Transpose.html">ConstTransposeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59eb71a8633da26de5e3e03351b2291e">transpose</a> () const</td></tr>
<tr class="separator:a59eb71a8633da26de5e3e03351b2291e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac501bd942994af7a95d95bee7a16ad2a" id="r_ac501bd942994af7a95d95bee7a16ad2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac501bd942994af7a95d95bee7a16ad2a">transposeInPlace</a> ()</td></tr>
<tr class="separator:ac501bd942994af7a95d95bee7a16ad2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8515f719046aa4851e385661f45595b0" id="r_a8515f719046aa4851e385661f45595b0"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8515f719046aa4851e385661f45595b0">value</a> () const</td></tr>
<tr class="separator:a8515f719046aa4851e385661f45595b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4225b90fcc74f18dd479b401124b3841" id="r_a4225b90fcc74f18dd479b401124b3841"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:a4225b90fcc74f18dd479b401124b3841"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4225b90fcc74f18dd479b401124b3841">visit</a> (Visitor &amp;func) const</td></tr>
<tr class="separator:a4225b90fcc74f18dd479b401124b3841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html">Eigen::DenseCoeffsBase&lt; Derived, DirectWriteAccessors &gt;</a></td></tr>
<tr class="memitem:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4" id="r_a2d768a9877f5f69f49432d447b552bfe"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a2d768a9877f5f69f49432d447b552bfe">cols</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bac522aee4402639189f387592000b inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4" id="r_af1bac522aee4402639189f387592000b"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#af1bac522aee4402639189f387592000b">colStride</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:af1bac522aee4402639189f387592000b inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b057c52245e486a101868d2578a24 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4" id="r_a749b057c52245e486a101868d2578a24"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a749b057c52245e486a101868d2578a24">derived</a> ()</td></tr>
<tr class="separator:a749b057c52245e486a101868d2578a24 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4" id="r_af9be7c19c7d1c415e18b0e0c7aca1e04"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#af9be7c19c7d1c415e18b0e0c7aca1e04">derived</a> () const</td></tr>
<tr class="separator:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e94e17926e1cf597deb2928e779cef6 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4" id="r_a4e94e17926e1cf597deb2928e779cef6"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a4e94e17926e1cf597deb2928e779cef6">innerStride</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:a4e94e17926e1cf597deb2928e779cef6 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb333f6f10467f6f8d7b59c213dea49e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4" id="r_abb333f6f10467f6f8d7b59c213dea49e"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#abb333f6f10467f6f8d7b59c213dea49e">outerStride</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:abb333f6f10467f6f8d7b59c213dea49e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4" id="r_ac22eb0695d00edd7d4a3b2d0a98b81c2"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bc5874eb4e320e54eb079b43b49d22 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4" id="r_a63bc5874eb4e320e54eb079b43b49d22"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a63bc5874eb4e320e54eb079b43b49d22">rowStride</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:a63bc5874eb4e320e54eb079b43b49d22 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4" id="r_ae106171b6fefd3f7af108a8283de36c9"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html">Eigen::DenseCoeffsBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="memitem:ad8b112af8c7600bc6c28281b5102735c inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_ad8b112af8c7600bc6c28281b5102735c"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ad8b112af8c7600bc6c28281b5102735c">coeff</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index) const</td></tr>
<tr class="separator:ad8b112af8c7600bc6c28281b5102735c inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2f2165c9e737086bb0124317c12c54 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_afc2f2165c9e737086bb0124317c12c54"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#afc2f2165c9e737086bb0124317c12c54">coeff</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> row, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> col) const</td></tr>
<tr class="separator:afc2f2165c9e737086bb0124317c12c54 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b18c0a2cf930857369943fa4a3f22d inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_af1b18c0a2cf930857369943fa4a3f22d"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af1b18c0a2cf930857369943fa4a3f22d">coeffRef</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index)</td></tr>
<tr class="separator:af1b18c0a2cf930857369943fa4a3f22d inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96df52273fe6a4fcb4489e9e5ae04959 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a96df52273fe6a4fcb4489e9e5ae04959"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a96df52273fe6a4fcb4489e9e5ae04959">coeffRef</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> row, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> col)</td></tr>
<tr class="separator:a96df52273fe6a4fcb4489e9e5ae04959 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a2d768a9877f5f69f49432d447b552bfe"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a2d768a9877f5f69f49432d447b552bfe">cols</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b057c52245e486a101868d2578a24 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a749b057c52245e486a101868d2578a24"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a749b057c52245e486a101868d2578a24">derived</a> ()</td></tr>
<tr class="separator:a749b057c52245e486a101868d2578a24 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_af9be7c19c7d1c415e18b0e0c7aca1e04"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af9be7c19c7d1c415e18b0e0c7aca1e04">derived</a> () const</td></tr>
<tr class="separator:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ee842510701180e0a3e8abd95e3f43 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_ae6ee842510701180e0a3e8abd95e3f43"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ae6ee842510701180e0a3e8abd95e3f43">operator()</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index)</td></tr>
<tr class="separator:ae6ee842510701180e0a3e8abd95e3f43 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7201533e7db05dd6d92360a7d906d9f9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a7201533e7db05dd6d92360a7d906d9f9"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a7201533e7db05dd6d92360a7d906d9f9">operator()</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> row, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> col)</td></tr>
<tr class="separator:a7201533e7db05dd6d92360a7d906d9f9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6341dc8943c5d105c90ed81b5e8e44 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a6b6341dc8943c5d105c90ed81b5e8e44"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a6b6341dc8943c5d105c90ed81b5e8e44">operator[]</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index)</td></tr>
<tr class="separator:a6b6341dc8943c5d105c90ed81b5e8e44 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_ac22eb0695d00edd7d4a3b2d0a98b81c2"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_ae106171b6fefd3f7af108a8283de36c9"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dc79704907b013f9a2b1bbf2a33bf5 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a66dc79704907b013f9a2b1bbf2a33bf5"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a66dc79704907b013f9a2b1bbf2a33bf5">w</a> ()</td></tr>
<tr class="separator:a66dc79704907b013f9a2b1bbf2a33bf5 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734c7dbbff44da60e76b18b5747c2636 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a734c7dbbff44da60e76b18b5747c2636"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a734c7dbbff44da60e76b18b5747c2636">w</a> () const</td></tr>
<tr class="separator:a734c7dbbff44da60e76b18b5747c2636 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216cf2015e9778c8229a8760bd438664 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a216cf2015e9778c8229a8760bd438664"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a216cf2015e9778c8229a8760bd438664">x</a> ()</td></tr>
<tr class="separator:a216cf2015e9778c8229a8760bd438664 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85019571c10aea3c6976993ac527e5a9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a85019571c10aea3c6976993ac527e5a9"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a85019571c10aea3c6976993ac527e5a9">x</a> () const</td></tr>
<tr class="separator:a85019571c10aea3c6976993ac527e5a9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbb19ac8c500c54956e4611d31ff464 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_afdbb19ac8c500c54956e4611d31ff464"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#afdbb19ac8c500c54956e4611d31ff464">y</a> ()</td></tr>
<tr class="separator:afdbb19ac8c500c54956e4611d31ff464 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a48ad4bd1d83f72c8dc48f28aa4289f inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a6a48ad4bd1d83f72c8dc48f28aa4289f"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a6a48ad4bd1d83f72c8dc48f28aa4289f">y</a> () const</td></tr>
<tr class="separator:a6a48ad4bd1d83f72c8dc48f28aa4289f inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24135e90d8ed283c103776fffe166bf5 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_a24135e90d8ed283c103776fffe166bf5"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a24135e90d8ed283c103776fffe166bf5">z</a> ()</td></tr>
<tr class="separator:a24135e90d8ed283c103776fffe166bf5 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add52b5ffd70a9c1041ae3e571dd88802 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4" id="r_add52b5ffd70a9c1041ae3e571dd88802"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#add52b5ffd70a9c1041ae3e571dd88802">z</a> () const</td></tr>
<tr class="separator:add52b5ffd70a9c1041ae3e571dd88802 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html">Eigen::DenseCoeffsBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="memitem:ad8b112af8c7600bc6c28281b5102735c inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_ad8b112af8c7600bc6c28281b5102735c"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#ad8b112af8c7600bc6c28281b5102735c">coeff</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index) const</td></tr>
<tr class="separator:ad8b112af8c7600bc6c28281b5102735c inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2f2165c9e737086bb0124317c12c54 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_afc2f2165c9e737086bb0124317c12c54"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#afc2f2165c9e737086bb0124317c12c54">coeff</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> row, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> col) const</td></tr>
<tr class="separator:afc2f2165c9e737086bb0124317c12c54 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_a2d768a9877f5f69f49432d447b552bfe"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a2d768a9877f5f69f49432d447b552bfe">cols</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b057c52245e486a101868d2578a24 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_a749b057c52245e486a101868d2578a24"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a749b057c52245e486a101868d2578a24">derived</a> ()</td></tr>
<tr class="separator:a749b057c52245e486a101868d2578a24 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_af9be7c19c7d1c415e18b0e0c7aca1e04"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#af9be7c19c7d1c415e18b0e0c7aca1e04">derived</a> () const</td></tr>
<tr class="separator:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab321758a2945955795af0fb2c66b7406 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_ab321758a2945955795af0fb2c66b7406"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#ab321758a2945955795af0fb2c66b7406">operator()</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index) const</td></tr>
<tr class="separator:ab321758a2945955795af0fb2c66b7406 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897aff52dd2720989ddfdc8583235407 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_a897aff52dd2720989ddfdc8583235407"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a897aff52dd2720989ddfdc8583235407">operator()</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> row, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> col) const</td></tr>
<tr class="separator:a897aff52dd2720989ddfdc8583235407 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c460eac0993e4a5e49e6d54e7ab63e9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_a5c460eac0993e4a5e49e6d54e7ab63e9"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a5c460eac0993e4a5e49e6d54e7ab63e9">operator[]</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index) const</td></tr>
<tr class="separator:a5c460eac0993e4a5e49e6d54e7ab63e9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_ac22eb0695d00edd7d4a3b2d0a98b81c2"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_ae106171b6fefd3f7af108a8283de36c9"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734c7dbbff44da60e76b18b5747c2636 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_a734c7dbbff44da60e76b18b5747c2636"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a734c7dbbff44da60e76b18b5747c2636">w</a> () const</td></tr>
<tr class="separator:a734c7dbbff44da60e76b18b5747c2636 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85019571c10aea3c6976993ac527e5a9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_a85019571c10aea3c6976993ac527e5a9"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a85019571c10aea3c6976993ac527e5a9">x</a> () const</td></tr>
<tr class="separator:a85019571c10aea3c6976993ac527e5a9 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a48ad4bd1d83f72c8dc48f28aa4289f inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_a6a48ad4bd1d83f72c8dc48f28aa4289f"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a6a48ad4bd1d83f72c8dc48f28aa4289f">y</a> () const</td></tr>
<tr class="separator:a6a48ad4bd1d83f72c8dc48f28aa4289f inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add52b5ffd70a9c1041ae3e571dd88802 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4" id="r_add52b5ffd70a9c1041ae3e571dd88802"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#add52b5ffd70a9c1041ae3e571dd88802">z</a> () const</td></tr>
<tr class="separator:add52b5ffd70a9c1041ae3e571dd88802 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structEigen_1_1EigenBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_structEigen_1_1EigenBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structEigen_1_1EigenBase.html">Eigen::EigenBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_structEigen_1_1EigenBase" id="r_a2d768a9877f5f69f49432d447b552bfe"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a2d768a9877f5f69f49432d447b552bfe">cols</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b057c52245e486a101868d2578a24 inherit pub_methods_structEigen_1_1EigenBase" id="r_a749b057c52245e486a101868d2578a24"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a749b057c52245e486a101868d2578a24">derived</a> ()</td></tr>
<tr class="separator:a749b057c52245e486a101868d2578a24 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_structEigen_1_1EigenBase" id="r_af9be7c19c7d1c415e18b0e0c7aca1e04"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#af9be7c19c7d1c415e18b0e0c7aca1e04">derived</a> () const</td></tr>
<tr class="separator:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_structEigen_1_1EigenBase" id="r_ac22eb0695d00edd7d4a3b2d0a98b81c2"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_structEigen_1_1EigenBase" id="r_ae106171b6fefd3f7af108a8283de36c9"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#ae106171b6fefd3f7af108a8283de36c9">size</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aed89b5cc6e3b7d9d5bd63aed245ccd6d" id="r_aed89b5cc6e3b7d9d5bd63aed245ccd6d"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed89b5cc6e3b7d9d5bd63aed245ccd6d">Constant</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:aed89b5cc6e3b7d9d5bd63aed245ccd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a7ece6c5629d1e9447a321fcb14ccd" id="r_a68a7ece6c5629d1e9447a321fcb14ccd"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68a7ece6c5629d1e9447a321fcb14ccd">Constant</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a2d768a9877f5f69f49432d447b552bfe">cols</a>, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:a68a7ece6c5629d1e9447a321fcb14ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdd3189ae3a41d250593334d82210cf" id="r_a1fdd3189ae3a41d250593334d82210cf"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fdd3189ae3a41d250593334d82210cf">Constant</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a>, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:a1fdd3189ae3a41d250593334d82210cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8098aa5971139a5585e623dddbea860" id="r_ad8098aa5971139a5585e623dddbea860"><td class="memItemLeft" align="right" valign="top">static const RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8098aa5971139a5585e623dddbea860">LinSpaced</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:ad8098aa5971139a5585e623dddbea860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.     <br /></td></tr>
<tr class="separator:ad8098aa5971139a5585e623dddbea860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef589c1dbd7fad93f97bd3fa1b1e768" id="r_aaef589c1dbd7fad93f97bd3fa1b1e768"><td class="memItemLeft" align="right" valign="top">static const RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaef589c1dbd7fad93f97bd3fa1b1e768">LinSpaced</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a>, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:aaef589c1dbd7fad93f97bd3fa1b1e768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <br /></td></tr>
<tr class="separator:aaef589c1dbd7fad93f97bd3fa1b1e768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cfbd436a8c9fc50defee5946451176" id="r_ac8cfbd436a8c9fc50defee5946451176"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEPRECATED const RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8cfbd436a8c9fc50defee5946451176">LinSpaced</a> (Sequential_t, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="separator:ac8cfbd436a8c9fc50defee5946451176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6d1dbfeb9f6491173a83eb44e14c1d" id="r_a1c6d1dbfeb9f6491173a83eb44e14c1d"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEPRECATED const RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c6d1dbfeb9f6491173a83eb44e14c1d">LinSpaced</a> (Sequential_t, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a>, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="separator:a1c6d1dbfeb9f6491173a83eb44e14c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc65501accd02c30f7c1840c2a30a41" id="r_a5dc65501accd02c30f7c1840c2a30a41"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a5dc65501accd02c30f7c1840c2a30a41"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, <a class="el" href="#a25f82d9f5a1367f64b9a61df53b836d4">PlainObject</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5dc65501accd02c30f7c1840c2a30a41">NullaryExpr</a> (const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a5dc65501accd02c30f7c1840c2a30a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3340c9b997f5b53a0131cf927f93b54c" id="r_a3340c9b997f5b53a0131cf927f93b54c"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a3340c9b997f5b53a0131cf927f93b54c"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, <a class="el" href="#a25f82d9f5a1367f64b9a61df53b836d4">PlainObject</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3340c9b997f5b53a0131cf927f93b54c">NullaryExpr</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a2d768a9877f5f69f49432d447b552bfe">cols</a>, const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a3340c9b997f5b53a0131cf927f93b54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9752ee59976a4b4aad860ad1a9093e7f" id="r_a9752ee59976a4b4aad860ad1a9093e7f"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a9752ee59976a4b4aad860ad1a9093e7f"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, <a class="el" href="#a25f82d9f5a1367f64b9a61df53b836d4">PlainObject</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9752ee59976a4b4aad860ad1a9093e7f">NullaryExpr</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a>, const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a9752ee59976a4b4aad860ad1a9093e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2755cb4023f7376880523626a8e05101" id="r_a2755cb4023f7376880523626a8e05101"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2755cb4023f7376880523626a8e05101">Ones</a> ()</td></tr>
<tr class="separator:a2755cb4023f7376880523626a8e05101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2a51018a73a766f5b91aef3487f013" id="r_a8b2a51018a73a766f5b91aef3487f013"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b2a51018a73a766f5b91aef3487f013">Ones</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a2d768a9877f5f69f49432d447b552bfe">cols</a>)</td></tr>
<tr class="separator:a8b2a51018a73a766f5b91aef3487f013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab710a58e4a80fbcb2594242372c8fe56" id="r_ab710a58e4a80fbcb2594242372c8fe56"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab710a58e4a80fbcb2594242372c8fe56">Ones</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a>)</td></tr>
<tr class="separator:ab710a58e4a80fbcb2594242372c8fe56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814abb451b48ed872819192dc188c19" id="r_ae814abb451b48ed872819192dc188c19"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae814abb451b48ed872819192dc188c19">Random</a> ()</td></tr>
<tr class="separator:ae814abb451b48ed872819192dc188c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97f8d9d08f969c733c8144be6225756" id="r_ae97f8d9d08f969c733c8144be6225756"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae97f8d9d08f969c733c8144be6225756">Random</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a2d768a9877f5f69f49432d447b552bfe">cols</a>)</td></tr>
<tr class="separator:ae97f8d9d08f969c733c8144be6225756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb5f974a8f0b67eac7080db1da0e308" id="r_a7eb5f974a8f0b67eac7080db1da0e308"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eb5f974a8f0b67eac7080db1da0e308">Random</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a>)</td></tr>
<tr class="separator:a7eb5f974a8f0b67eac7080db1da0e308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422ddeef58bedc7bddb1d4357688d761" id="r_a422ddeef58bedc7bddb1d4357688d761"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero</a> ()</td></tr>
<tr class="separator:a422ddeef58bedc7bddb1d4357688d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41a9b5050ed27d9e93c82c9c8622cd3" id="r_ae41a9b5050ed27d9e93c82c9c8622cd3"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae41a9b5050ed27d9e93c82c9c8622cd3">Zero</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a2d768a9877f5f69f49432d447b552bfe">cols</a>)</td></tr>
<tr class="separator:ae41a9b5050ed27d9e93c82c9c8622cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22f79b812fa564061042407f2ba8f5b" id="r_ac22f79b812fa564061042407f2ba8f5b"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac22f79b812fa564061042407f2ba8f5b">Zero</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a>)</td></tr>
<tr class="separator:ac22f79b812fa564061042407f2ba8f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa13738d38e34da7a183e58dbbc74c6a8" id="r_aa13738d38e34da7a183e58dbbc74c6a8"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa13738d38e34da7a183e58dbbc74c6a8">DenseBase</a> ()=default</td></tr>
<tr class="separator:aa13738d38e34da7a183e58dbbc74c6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a" id="r_a3806d3f42de165878dace160e6aba40a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3806d3f42de165878dace160e6aba40a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt; &amp;m)</td></tr>
<tr class="separator:a3806d3f42de165878dace160e6aba40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a306d9418d4b34874e9005d961c490cd2" name="a306d9418d4b34874e9005d961c490cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306d9418d4b34874e9005d961c490cd2">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef random_access_iterator_type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the const version of iterator (aka read-only) </p>

</div>
</div>
<a id="af5130902770642a1a057a99c397d357d" name="af5130902770642a1a057a99c397d357d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5130902770642a1a057a99c397d357d">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef random_access_iterator_type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">RandomAccessIterator</a> iterator type as returned by the <a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin()</a> and <a class="el" href="#ae71d079e16d91360d10066b316b48485">end()</a> methods. </p>

</div>
</div>
<a id="a84e3075eb0c3841a7badabd08c4860d1" name="a84e3075eb0c3841a7badabd08c4860d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e3075eb0c3841a7badabd08c4860d1">&#9670;&#160;</a></span>PlainArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1Array.html">Array</a>&lt;typename internal::traits&lt;Derived&gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a> | (internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a7392c9b2ad41ba3c16fdc5306c04d581">::Flags</a> &amp; <a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> : <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0ad2baadea085372837b0e80dc93be1306">::MaxRowsAtCompileTime</a>, internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0acc3a41000cf1d29dd1a320b2a09d2a65">::MaxColsAtCompileTime</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::PlainArray</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The plain array type corresponding to this expression. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a25f82d9f5a1367f64b9a61df53b836d4" title="The plain matrix or array type corresponding to this expression.">PlainObject</a> </dd></dl>

</div>
</div>
<a id="a41c5c57adb01354a7f0e67d5579c2926" name="a41c5c57adb01354a7f0e67d5579c2926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c5c57adb01354a7f0e67d5579c2926">&#9670;&#160;</a></span>PlainMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt;typename internal::traits&lt;Derived&gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a> | (internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a7392c9b2ad41ba3c16fdc5306c04d581">::Flags</a> &amp; <a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> : <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0ad2baadea085372837b0e80dc93be1306">::MaxRowsAtCompileTime</a>, internal::traits&lt;Derived&gt;<a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0acc3a41000cf1d29dd1a320b2a09d2a65">::MaxColsAtCompileTime</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::PlainMatrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The plain matrix type corresponding to this expression. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a25f82d9f5a1367f64b9a61df53b836d4" title="The plain matrix or array type corresponding to this expression.">PlainObject</a> </dd></dl>

</div>
</div>
<a id="a25f82d9f5a1367f64b9a61df53b836d4" name="a25f82d9f5a1367f64b9a61df53b836d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f82d9f5a1367f64b9a61df53b836d4">&#9670;&#160;</a></span>PlainObject</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::conditional_t&lt;internal::is_same&lt;typename internal::traits&lt;Derived&gt;::XprKind, <a class="el" href="structEigen_1_1MatrixXpr.html">MatrixXpr</a>&gt;<a class="el" href="#a8515f719046aa4851e385661f45595b0">::value</a>, <a class="el" href="#a41c5c57adb01354a7f0e67d5579c2926">PlainMatrix</a>, <a class="el" href="#a84e3075eb0c3841a7badabd08c4860d1">PlainArray</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::PlainObject</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The plain matrix or array type corresponding to this expression. </p>
<p>This is not necessarily exactly the return type of <a class="el" href="#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval()</a>. In the case of plain matrices, the return type of <a class="el" href="#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval()</a> is a const reference to a matrix, not a matrix! It is however guaranteed that the return type of <a class="el" href="#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval()</a> is either PlainObject or const PlainObject&amp;. </p>

</div>
</div>
<a id="a5feed465b3a8e60c47e73ecce83e39a2" name="a5feed465b3a8e60c47e73ecce83e39a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5feed465b3a8e60c47e73ecce83e39a2">&#9670;&#160;</a></span>Scalar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::traits&lt;Derived&gt;::Scalar <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Scalar</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The numeric type of the expression' coefficients, e.g. float, double, int or std::complex&lt;float&gt;, etc. </p>

</div>
</div>
<a id="a2d1aba3f6c414715d830f760913c7e00" name="a2d1aba3f6c414715d830f760913c7e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1aba3f6c414715d830f760913c7e00">&#9670;&#160;</a></span>StorageIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::traits&lt;Derived&gt;::StorageIndex <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::StorageIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to store indices. </p>
<p>This typedef is relevant for types that store multiple indices such as <a class="el" href="classEigen_1_1PermutationMatrix.html" title="Permutation matrix.">PermutationMatrix</a> or <a class="el" href="classEigen_1_1Transpositions.html" title="Represents a sequence of transpositions (row/column interchange)">Transpositions</a>, otherwise it defaults to <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Eigen::Index</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="TopicPreprocessorDirectives.html">Preprocessor directives</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Eigen::Index</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html" title="Base class of any sparse matrices or sparse expressions.">SparseMatrixBase</a>. </dd></dl>

</div>
</div>
<a id="a9276182dab8236c33f1e7abf491d504d" name="a9276182dab8236c33f1e7abf491d504d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9276182dab8236c33f1e7abf491d504d">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The numeric type of the expression' coefficients, e.g. float, double, int or std::complex&lt;float&gt;, etc.</p>
<p>It is an alias for the Scalar type </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad65279b1533923e9a69ce51c7950e9f0" name="ad65279b1533923e9a69ce51c7950e9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65279b1533923e9a69ce51c7950e9f0">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab" name="ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab"></a>RowsAtCompileTime&#160;</td><td class="fielddoc"><p>The number of rows at compile-time. This is just a copy of the value provided by the <em>Derived</em> type. If a value is not known at compile-time, it is set to the <em>Dynamic</em> constant. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structEigen_1_1EigenBase.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">MatrixBase::rows()</a>, <a class="el" href="structEigen_1_1EigenBase.html#a2d768a9877f5f69f49432d447b552bfe">MatrixBase::cols()</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441" name="ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441"></a>ColsAtCompileTime&#160;</td><td class="fielddoc"><p>The number of columns at compile-time. This is just a copy of the value provided by the <em>Derived</em> type. If a value is not known at compile-time, it is set to the <em>Dynamic</em> constant. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structEigen_1_1EigenBase.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">MatrixBase::rows()</a>, <a class="el" href="structEigen_1_1EigenBase.html#a2d768a9877f5f69f49432d447b552bfe">MatrixBase::cols()</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0a25cb495affdbd796198462b8ef06be91" name="ad65279b1533923e9a69ce51c7950e9f0a25cb495affdbd796198462b8ef06be91"></a>SizeAtCompileTime&#160;</td><td class="fielddoc"><p>This is equal to the number of coefficients, i.e. the number of rows times the number of columns, or to <em>Dynamic</em> if this is not known at compile-time. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0ad2baadea085372837b0e80dc93be1306" name="ad65279b1533923e9a69ce51c7950e9f0ad2baadea085372837b0e80dc93be1306"></a>MaxRowsAtCompileTime&#160;</td><td class="fielddoc"><p>This value is equal to the maximum possible number of rows that this expression might have. If this expression might have an arbitrarily high number of rows, this value is set to <em>Dynamic</em>.</p>
<p>This value is useful to know when evaluating an expression, in order to determine whether it is possible to avoid doing a dynamic memory allocation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0adb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0acc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a3a459062d39cb34452518f5f201161d2">MaxSizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0acc3a41000cf1d29dd1a320b2a09d2a65" name="ad65279b1533923e9a69ce51c7950e9f0acc3a41000cf1d29dd1a320b2a09d2a65"></a>MaxColsAtCompileTime&#160;</td><td class="fielddoc"><p>This value is equal to the maximum possible number of columns that this expression might have. If this expression might have an arbitrarily high number of columns, this value is set to <em>Dynamic</em>.</p>
<p>This value is useful to know when evaluating an expression, in order to determine whether it is possible to avoid doing a dynamic memory allocation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0ad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a3a459062d39cb34452518f5f201161d2">MaxSizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0a3a459062d39cb34452518f5f201161d2" name="ad65279b1533923e9a69ce51c7950e9f0a3a459062d39cb34452518f5f201161d2"></a>MaxSizeAtCompileTime&#160;</td><td class="fielddoc"><p>This value is equal to the maximum possible number of coefficients that this expression might have. If this expression might have an arbitrarily high number of coefficients, this value is set to <em>Dynamic</em>.</p>
<p>This value is useful to know when evaluating an expression, in order to determine whether it is possible to avoid doing a dynamic memory allocation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0a25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0ad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>, <a class="el" href="#ad65279b1533923e9a69ce51c7950e9f0acc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0a1156955c8099c5072934b74c72654ed0" name="ad65279b1533923e9a69ce51c7950e9f0a1156955c8099c5072934b74c72654ed0"></a>IsVectorAtCompileTime&#160;</td><td class="fielddoc"><p>This is set to true if either the number of rows or the number of columns is known at compile-time to be equal to 1. Indeed, in that case, we are dealing with a column-vector (if there is only one column) or with a row-vector (if there is only one row). </p>
</td></tr>
<tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0a4d4548a01ba37a6c2031a3c1f0a37d34" name="ad65279b1533923e9a69ce51c7950e9f0a4d4548a01ba37a6c2031a3c1f0a37d34"></a>NumDimensions&#160;</td><td class="fielddoc"><p>This value is equal to Tensor::NumDimensions, i.e. 0 for scalars, 1 for vectors, and 2 for matrices. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0a7392c9b2ad41ba3c16fdc5306c04d581" name="ad65279b1533923e9a69ce51c7950e9f0a7392c9b2ad41ba3c16fdc5306c04d581"></a>Flags&#160;</td><td class="fielddoc"><p>This stores expression <a class="el" href="group__flags.html">Flags</a> flags which may or may not be inherited by new expressions constructed from this one. See the <a class="el" href="group__flags.html">list of flags</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad65279b1533923e9a69ce51c7950e9f0a406b6af91d61d348ba1c9764bdd66008" name="ad65279b1533923e9a69ce51c7950e9f0a406b6af91d61d348ba1c9764bdd66008"></a>IsRowMajor&#160;</td><td class="fielddoc"><p>True if this expression has row-major storage order. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa13738d38e34da7a183e58dbbc74c6a8" name="aa13738d38e34da7a183e58dbbc74c6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13738d38e34da7a183e58dbbc74c6a8">&#9670;&#160;</a></span>DenseBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::DenseBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Do nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae42ab60296c120e9f45ce3b44e1761a4" name="ae42ab60296c120e9f45ce3b44e1761a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42ab60296c120e9f45ce3b44e1761a4">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if all coefficients are true</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Vector3f</a> boxMin(Vector3f::Zero()), boxMax(Vector3f::Ones());</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Vector3f</a> p0 = Vector3f::Random(), p1 = Vector3f::Random().cwiseAbs();</div>
<div class="line"><span class="comment">// let&#39;s check if p0 and p1 are inside the axis aligned box defined by the corners boxMin,boxMax:</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Is (&quot;</span> &lt;&lt; p0.<a class="code hl_function" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose</a>()</div>
<div class="line">     &lt;&lt; <span class="stringliteral">&quot;) inside the box: &quot;</span> &lt;&lt; ((boxMin.array() &lt; p0.<a class="code hl_function" href="classEigen_1_1MatrixBase.html#a6d285ea9b37cbd80209e70543d10fd67">array</a>()).all() &amp;&amp; (boxMax.array() &gt; p0.<a class="code hl_function" href="classEigen_1_1MatrixBase.html#a6d285ea9b37cbd80209e70543d10fd67">array</a>()).all()) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Is (&quot;</span> &lt;&lt; p1.transpose()</div>
<div class="line">     &lt;&lt; <span class="stringliteral">&quot;) inside the box: &quot;</span> &lt;&lt; ((boxMin.array() &lt; p1.array()).all() &amp;&amp; (boxMax.array() &gt; p1.array()).all()) &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a43cbcd866a0737eb56642c2e992f0afd"><div class="ttname"><a href="#a43cbcd866a0737eb56642c2e992f0afd">Eigen::DenseBase::transpose</a></div><div class="ttdeci">TransposeReturnType transpose()</div><div class="ttdef"><b>Definition</b> Transpose.h:160</div></div>
<div class="ttc" id="aclassEigen_1_1MatrixBase_html_a6d285ea9b37cbd80209e70543d10fd67"><div class="ttname"><a href="classEigen_1_1MatrixBase.html#a6d285ea9b37cbd80209e70543d10fd67">Eigen::MatrixBase::array</a></div><div class="ttdeci">ArrayWrapper&lt; Derived &gt; array()</div><div class="ttdef"><b>Definition</b> MatrixBase.h:320</div></div>
<div class="ttc" id="aclassEigen_1_1Matrix_html"><div class="ttname"><a href="classEigen_1_1Matrix.html">Eigen::Matrix</a></div><div class="ttdoc">The matrix class, also used for vectors and row-vectors.</div><div class="ttdef"><b>Definition</b> Matrix.h:186</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#abfbf4cb72dd577e62fbe035b1c53e695">any()</a>, Cwise::operator&lt;() </dd></dl>

</div>
</div>
<a id="af1e669fd3aaae50a4870dc1b8f3b8884" name="af1e669fd3aaae50a4870dc1b8f3b8884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e669fd3aaae50a4870dc1b8f3b8884">&#9670;&#160;</a></span>allFinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::allFinite </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>*this</code> contains only finite numbers, i.e., no NaN and no +/-INF values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasNaN() </dd></dl>

</div>
</div>
<a id="abfbf4cb72dd577e62fbe035b1c53e695" name="abfbf4cb72dd577e62fbe035b1c53e695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbf4cb72dd577e62fbe035b1c53e695">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::any </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if at least one coefficient is true</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae42ab60296c120e9f45ce3b44e1761a4">all()</a> </dd></dl>

</div>
</div>
<a id="a57591454af931f9dffa71c9da28d5641" name="a57591454af931f9dffa71c9da28d5641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57591454af931f9dffa71c9da28d5641">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#af5130902770642a1a057a99c397d357d">::iterator</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns an iterator to the first element of the 1D vector or array This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae71d079e16d91360d10066b316b48485">end()</a>, <a class="el" href="#ae9a3dfd9b826ba3103de0128576fb15b">cbegin()</a> </dd></dl>

</div>
</div>
<a id="ad9368ce70b06167ec5fc19398d329f5e" name="ad9368ce70b06167ec5fc19398d329f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9368ce70b06167ec5fc19398d329f5e">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a306d9418d4b34874e9005d961c490cd2">::const_iterator</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin()</a> </p>

</div>
</div>
<a id="ae9a3dfd9b826ba3103de0128576fb15b" name="ae9a3dfd9b826ba3103de0128576fb15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a3dfd9b826ba3103de0128576fb15b">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a306d9418d4b34874e9005d961c490cd2">::const_iterator</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a read-only const_iterator to the first element of the 1D vector or array This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aeb3b76f02986c2af2521d07164b5ffde">cend()</a>, <a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin()</a> </dd></dl>

</div>
</div>
<a id="aeb3b76f02986c2af2521d07164b5ffde" name="aeb3b76f02986c2af2521d07164b5ffde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3b76f02986c2af2521d07164b5ffde">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a306d9418d4b34874e9005d961c490cd2">::const_iterator</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a read-only const_iterator to the element following the last element of the 1D vector or array This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin()</a>, <a class="el" href="#aeb3b76f02986c2af2521d07164b5ffde">cend()</a> </dd></dl>

</div>
</div>
<a id="a1c0e1b6067ec1de6cb8799da55aa7d30" name="a1c0e1b6067ec1de6cb8799da55aa7d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0e1b6067ec1de6cb8799da55aa7d30">&#9670;&#160;</a></span>colwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ColwiseReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::colwise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a> wrapper of *this providing additional partial reduction operations</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa1cabd3404528fe8cec4bab43d74bffc">rowwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, <a class="el" href="group__TutorialReductionsVisitorsBroadcasting.html">Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a id="a58837c81de446efbdb58da07b73a63c1" name="a58837c81de446efbdb58da07b73a63c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58837c81de446efbdb58da07b73a63c1">&#9670;&#160;</a></span>colwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html">ConstColwiseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::colwise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a> wrapper of *this broadcasting and partial reductions</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.<a class="code hl_function" href="#a58837c81de446efbdb58da07b73a63c1">colwise</a>().<a class="code hl_function" href="classEigen_1_1VectorwiseOp.html#a7030fc687c24d687ed7cd70733ba611c">sum</a>() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum absolute value of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.cwiseAbs().<a class="code hl_function" href="#a58837c81de446efbdb58da07b73a63c1">colwise</a>().<a class="code hl_function" href="classEigen_1_1VectorwiseOp.html#a6646b584db116c1661b5bb56750bd6f6">maxCoeff</a>() &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a58837c81de446efbdb58da07b73a63c1"><div class="ttname"><a href="#a58837c81de446efbdb58da07b73a63c1">Eigen::DenseBase::colwise</a></div><div class="ttdeci">ConstColwiseReturnType colwise() const</div><div class="ttdef"><b>Definition</b> DenseBase.h:511</div></div>
<div class="ttc" id="aclassEigen_1_1VectorwiseOp_html_a6646b584db116c1661b5bb56750bd6f6"><div class="ttname"><a href="classEigen_1_1VectorwiseOp.html#a6646b584db116c1661b5bb56750bd6f6">Eigen::VectorwiseOp::maxCoeff</a></div><div class="ttdeci">const MaxCoeffReturnType maxCoeff() const</div><div class="ttdef"><b>Definition</b> VectorwiseOp.h:387</div></div>
<div class="ttc" id="aclassEigen_1_1VectorwiseOp_html_a7030fc687c24d687ed7cd70733ba611c"><div class="ttname"><a href="classEigen_1_1VectorwiseOp.html#a7030fc687c24d687ed7cd70733ba611c">Eigen::VectorwiseOp::sum</a></div><div class="ttdeci">const SumReturnType sum() const</div><div class="ttdef"><b>Definition</b> VectorwiseOp.h:458</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa1cabd3404528fe8cec4bab43d74bffc">rowwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, <a class="el" href="group__TutorialReductionsVisitorsBroadcasting.html">Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a id="aed89b5cc6e3b7d9d5bd63aed245ccd6d" name="aed89b5cc6e3b7d9d5bd63aed245ccd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed89b5cc6e3b7d9d5bd63aed245ccd6d">&#9670;&#160;</a></span>Constant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a constant matrix of value <em>value</em> </dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays.">DenseBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a68a7ece6c5629d1e9447a321fcb14ccd" name="a68a7ece6c5629d1e9447a321fcb14ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a7ece6c5629d1e9447a321fcb14ccd">&#9670;&#160;</a></span>Constant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a constant matrix of value <em>value</em> </dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays.">DenseBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a> should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a1fdd3189ae3a41d250593334d82210cf" name="a1fdd3189ae3a41d250593334d82210cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdd3189ae3a41d250593334d82210cf">&#9670;&#160;</a></span>Constant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a constant matrix of value <em>value</em> </dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays.">DenseBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a> should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="ab778f1c907d15d20fcc23f32ab102172" name="ab778f1c907d15d20fcc23f32ab102172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab778f1c907d15d20fcc23f32ab102172">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of coefficients which evaluate to true</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae42ab60296c120e9f45ce3b44e1761a4">all()</a>, <a class="el" href="#abfbf4cb72dd577e62fbe035b1c53e695">any()</a> </dd></dl>

</div>
</div>
<a id="ae71d079e16d91360d10066b316b48485" name="ae71d079e16d91360d10066b316b48485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71d079e16d91360d10066b316b48485">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#af5130902770642a1a057a99c397d357d">::iterator</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns an iterator to the element following the last element of the 1D vector or array This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin()</a>, <a class="el" href="#aeb3b76f02986c2af2521d07164b5ffde">cend()</a> </dd></dl>

</div>
</div>
<a id="ab34773522e43bfb02e9cf652d7b5dd60" name="ab34773522e43bfb02e9cf652d7b5dd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34773522e43bfb02e9cf652d7b5dd60">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a306d9418d4b34874e9005d961c490cd2">::const_iterator</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="#ae71d079e16d91360d10066b316b48485">end()</a> </p>

</div>
</div>
<a id="aa73e57a2f0f7cfcb4ad4d55ea0b6414b" name="aa73e57a2f0f7cfcb4ad4d55ea0b6414b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">&#9670;&#160;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EvalReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::eval </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix or vector obtained by evaluating this expression.</dd></dl>
<p>Notice that in the case of a plain matrix or vector (not an expression) this function just returns a const reference, in order to avoid a useless copy.</p>
<dl class="section warning"><dt>Warning</dt><dd>Be careful with <a class="el" href="#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval()</a> and the auto C++ keyword, as detailed in this <a class="el" href="TopicPitfalls.html#TopicPitfalls_auto_keyword">page </a>. </dd></dl>

</div>
</div>
<a id="a9be169c308801411aa24be93d30930bf" name="a9be169c308801411aa24be93d30930bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be169c308801411aa24be93d30930bf">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="#ac2f1e50d1f567da38da1d2f07c5ab559">setConstant()</a>: sets all coefficients in this expression to <em>val</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac2f1e50d1f567da38da1d2f07c5ab559">setConstant()</a>, <a class="el" href="#a68a7ece6c5629d1e9447a321fcb14ccd">Constant()</a>, class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="ae2db4b4596edd1bf7e1c43ac2d306047" name="ae2db4b4596edd1bf7e1c43ac2d306047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2db4b4596edd1bf7e1c43ac2d306047">&#9670;&#160;</a></span>flagged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;unsigned int Added, unsigned int Removed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEPRECATED const Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::flagged </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated</a></b></dt><dd>it now returns <code>*this</code> </dd></dl>

</div>
</div>
<a id="a148e20e32aa3ceca13e0a49c2cc584fc" name="a148e20e32aa3ceca13e0a49c2cc584fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148e20e32aa3ceca13e0a49c2cc584fc">&#9670;&#160;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classEigen_1_1WithFormat.html" title="Pseudo expression providing matrix output with given format.">WithFormat</a> proxy object allowing to print a matrix the with given format <em>fmt</em>.</dd></dl>
<p>See class <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed.">IOFormat</a> for some examples.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed.">IOFormat</a>, class <a class="el" href="classEigen_1_1WithFormat.html" title="Pseudo expression providing matrix output with given format.">WithFormat</a> </dd></dl>

</div>
</div>
<a id="a58ca41d9635a8ab3c5a268ef3f7f0d75" name="a58ca41d9635a8ab3c5a268ef3f7f0d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ca41d9635a8ab3c5a268ef3f7f0d75">&#9670;&#160;</a></span>innerSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::innerSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a vector, this is just the size. For a matrix (non-vector), this is the minor dimension with respect to the <a class="el" href="group__TopicStorageOrders.html">storage order</a>, i.e., the number of rows for a column-major matrix, and the number of columns for a row-major matrix. </dd></dl>

</div>
</div>
<a id="ae8443357b808cd393be1b51974213f9c" name="ae8443357b808cd393be1b51974213f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8443357b808cd393be1b51974213f9c">&#9670;&#160;</a></span>isApprox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isApprox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> is approximately equal to <em>other</em>, within the precision determined by <em>prec</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The fuzzy compares are done multiplicatively. Two vectors \( v \) and \( w \) are considered to be approximately equal within precision \( p \) if <p class="formulaDsp">
\[ \Vert v - w \Vert \leqslant p\,\min(\Vert v\Vert, \Vert w\Vert). \]
</p>
 For matrices, the comparison is done using the Hilbert-Schmidt norm (aka Frobenius norm L2 norm).</dd>
<dd>
Because of the multiplicativeness of this comparison, one can't use this function to check whether <code>*this</code> is approximately equal to the zero matrix or vector. Indeed, <code>isApprox(zero)</code> returns false unless <code>*this</code> itself is exactly the zero matrix or vector. If you want to test whether <code>*this</code> is zero, use internal::isMuchSmallerThan(const
RealScalar&amp;, RealScalar) instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>internal::isMuchSmallerThan(const RealScalar&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a id="af9b150d48bc5e4366887ccb466e40c6b" name="af9b150d48bc5e4366887ccb466e40c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b150d48bc5e4366887ccb466e40c6b">&#9670;&#160;</a></span>isApproxToConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isApproxToConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if all coefficients in this matrix are approximately equal to <em>val</em>, to within precision <em>prec</em> </dd></dl>

</div>
</div>
<a id="a1ca84e4179b3e5081ed11d89bbd9e74f" name="a1ca84e4179b3e5081ed11d89bbd9e74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca84e4179b3e5081ed11d89bbd9e74f">&#9670;&#160;</a></span>isConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is just an alias for <a class="el" href="#af9b150d48bc5e4366887ccb466e40c6b">isApproxToConstant()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if all coefficients in this matrix are approximately equal to <em>value</em>, to within precision <em>prec</em> </dd></dl>

</div>
</div>
<a id="a3c4db0c6dd974fa88bbb58b2cf3d5664" name="a3c4db0c6dd974fa88bbb58b2cf3d5664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4db0c6dd974fa88bbb58b2cf3d5664">&#9670;&#160;</a></span>isMuchSmallerThan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isMuchSmallerThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the norm of <code>*this</code> is much smaller than the norm of <em>other</em>, within the precision determined by <em>prec</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The fuzzy compares are done multiplicatively. A vector \( v \) is considered to be much smaller than a vector \( w \) within precision \( p \) if <p class="formulaDsp">
\[ \Vert v \Vert \leqslant p\,\Vert w\Vert. \]
</p>
 For matrices, the comparison is done using the Hilbert-Schmidt norm.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae8443357b808cd393be1b51974213f9c">isApprox()</a>, isMuchSmallerThan(const RealScalar&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a id="adfca6ff4e473f68fbbeabbd03b7504a9" name="adfca6ff4e473f68fbbeabbd03b7504a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfca6ff4e473f68fbbeabbd03b7504a9">&#9670;&#160;</a></span>isMuchSmallerThan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isMuchSmallerThan </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the norm of <code>*this</code> is much smaller than <em>other</em>, within the precision determined by <em>prec</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The fuzzy compares are done multiplicatively. A vector \( v \) is considered to be much smaller than \( x \) within precision \( p \) if <p class="formulaDsp">
\[ \Vert v \Vert \leqslant p\,\vert x\vert. \]
</p>
</dd></dl>
<p>For matrices, the comparison is done using the Hilbert-Schmidt norm. For this reason, the value of the reference scalar <em>other</em> should come from the Hilbert-Schmidt norm of a reference matrix of same dimensions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae8443357b808cd393be1b51974213f9c">isApprox()</a>, isMuchSmallerThan(const DenseBase&lt;OtherDerived&gt;&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a id="aa56d6b4477cd3c92a9cf42f4b96e47c2" name="aa56d6b4477cd3c92a9cf42f4b96e47c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56d6b4477cd3c92a9cf42f4b96e47c2">&#9670;&#160;</a></span>isOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isOnes </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to the matrix where all coefficients are equal to 1, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Ones();</div>
<div class="line">m(0, 2) += 1e-4;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isOnes() returns: &quot;</span> &lt;&lt; m.<a class="code hl_function" href="#aa56d6b4477cd3c92a9cf42f4b96e47c2">isOnes</a>() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isOnes(1e-3) returns: &quot;</span> &lt;&lt; m.<a class="code hl_function" href="#aa56d6b4477cd3c92a9cf42f4b96e47c2">isOnes</a>(1e-3) &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_aa56d6b4477cd3c92a9cf42f4b96e47c2"><div class="ttname"><a href="#aa56d6b4477cd3c92a9cf42f4b96e47c2">Eigen::DenseBase::isOnes</a></div><div class="ttdeci">bool isOnes(const RealScalar &amp;prec=NumTraits&lt; Scalar &gt;::dummy_precision()) const</div><div class="ttdef"><b>Definition</b> CwiseNullaryOp.h:676</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#a2755cb4023f7376880523626a8e05101">Ones()</a> </dd></dl>

</div>
</div>
<a id="af36014ec300f53a65083057ed4e89822" name="af36014ec300f53a65083057ed4e89822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36014ec300f53a65083057ed4e89822">&#9670;&#160;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isZero </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to the zero matrix, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Zero();</div>
<div class="line">m(0, 2) = 1e-4;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isZero() returns: &quot;</span> &lt;&lt; m.<a class="code hl_function" href="#af36014ec300f53a65083057ed4e89822">isZero</a>() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isZero(1e-3) returns: &quot;</span> &lt;&lt; m.<a class="code hl_function" href="#af36014ec300f53a65083057ed4e89822">isZero</a>(1e-3) &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_af36014ec300f53a65083057ed4e89822"><div class="ttname"><a href="#af36014ec300f53a65083057ed4e89822">Eigen::DenseBase::isZero</a></div><div class="ttdeci">bool isZero(const RealScalar &amp;prec=NumTraits&lt; Scalar &gt;::dummy_precision()) const</div><div class="ttdef"><b>Definition</b> CwiseNullaryOp.h:533</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a> </dd></dl>

</div>
</div>
<a id="af1867382668870ff240913bed8aedd71" name="af1867382668870ff240913bed8aedd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1867382668870ff240913bed8aedd71">&#9670;&#160;</a></span>lazyAssign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEPRECATED Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::lazyAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ad8098aa5971139a5585e623dddbea860" name="ad8098aa5971139a5585e623dddbea860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8098aa5971139a5585e623dddbea860">&#9670;&#160;</a></span>LinSpaced() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::LinSpaced </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly spaced vector.    </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; VectorXi::LinSpaced(4, 7, 10).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXd::LinSpaced(5, 0.0, 1.0).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>For integer scalar types, an even spacing is possible if and only if the length of the range, i.e., <code>high-low</code> is a scalar multiple of <code>size-1</code>, or if <code>size</code> is a scalar multiple of the number of values <code>high-low+1</code> (meaning each value can be repeated the same number of time). If one of these two considions is not satisfied, then <code>high</code> is lowered to the largest value satisfying one of this constraint. Here are some examples:</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Even spacing inputs:&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 4).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 8).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 15).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Uneven spacing inputs:&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 7).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 9).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 16).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5d1ce9e801fa502e02b9b8cd9141ad0a" title="Sets a linearly spaced vector.">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>    Special version for fixed <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a> types which does not require the <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ae106171b6fefd3f7af108a8283de36c9">size</a> parameter. </dd></dl>

</div>
</div>
<a id="aaef589c1dbd7fad93f97bd3fa1b1e768" name="aaef589c1dbd7fad93f97bd3fa1b1e768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef589c1dbd7fad93f97bd3fa1b1e768">&#9670;&#160;</a></span>LinSpaced() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::LinSpaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly spaced vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; VectorXi::LinSpaced(4, 7, 10).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXd::LinSpaced(5, 0.0, 1.0).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>For integer scalar types, an even spacing is possible if and only if the length of the range, i.e., <code>high-low</code> is a scalar multiple of <code>size-1</code>, or if <code>size</code> is a scalar multiple of the number of values <code>high-low+1</code> (meaning each value can be repeated the same number of time). If one of these two considions is not satisfied, then <code>high</code> is lowered to the largest value satisfying one of this constraint. Here are some examples:</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Even spacing inputs:&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 4).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 8).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 15).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Uneven spacing inputs:&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 7).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 9).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXi::LinSpaced(8, 1, 16).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5d1ce9e801fa502e02b9b8cd9141ad0a" title="Sets a linearly spaced vector.">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="ac8cfbd436a8c9fc50defee5946451176" name="ac8cfbd436a8c9fc50defee5946451176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cfbd436a8c9fc50defee5946451176">&#9670;&#160;</a></span>LinSpaced() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEPRECATED const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::LinSpaced </td>
          <td>(</td>
          <td class="paramtype">Sequential_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated</a></b></dt><dd>because of accuracy loss. In <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3, it is an alias for <a class="el" href="#ad8098aa5971139a5585e623dddbea860" title="Sets a linearly spaced vector.">LinSpaced(const Scalar&amp;,const Scalar&amp;)</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad8098aa5971139a5585e623dddbea860" title="Sets a linearly spaced vector.">LinSpaced(const Scalar&amp;, const Scalar&amp;)</a> </dd></dl>

</div>
</div>
<a id="a1c6d1dbfeb9f6491173a83eb44e14c1d" name="a1c6d1dbfeb9f6491173a83eb44e14c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6d1dbfeb9f6491173a83eb44e14c1d">&#9670;&#160;</a></span>LinSpaced() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEPRECATED const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::LinSpaced </td>
          <td>(</td>
          <td class="paramtype">Sequential_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated</a></b></dt><dd>because of accuracy loss. In <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3, it is an alias for <a class="el" href="#aaef589c1dbd7fad93f97bd3fa1b1e768" title="Sets a linearly spaced vector.">LinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a></dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; VectorXi::LinSpaced(Sequential, 4, 7, 10).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXd::LinSpaced(Sequential, 5, 0.0, 1.0).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aaef589c1dbd7fad93f97bd3fa1b1e768" title="Sets a linearly spaced vector.">LinSpaced(Index,const Scalar&amp;, const Scalar&amp;)</a>, <a class="el" href="#a5d1ce9e801fa502e02b9b8cd9141ad0a" title="Sets a linearly spaced vector.">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a> </dd></dl>

</div>
</div>
<a id="a7e6987d106f1cca3ac6ab36d288cc8e1" name="a7e6987d106f1cca3ac6ab36d288cc8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6987d106f1cca3ac6ab36d288cc8e1">&#9670;&#160;</a></span>maxCoeff() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::maxCoeff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum of all coefficients of <code>*this</code>. In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered. </dd></dl>

</div>
</div>
<a id="aced8ffda52ff061b6586ace2657ebf30" name="aced8ffda52ff061b6586ace2657ebf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced8ffda52ff061b6586ace2657ebf30">&#9670;&#160;</a></span>maxCoeff() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation, typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::maxCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum of all coefficients of *this and puts in *index its location.</dd></dl>
<p>In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </p><dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::maxCoeff(IndexType*,IndexType*), DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::visitor(), <a class="el" href="#a7e6987d106f1cca3ac6ab36d288cc8e1">DenseBase::maxCoeff()</a> </dd></dl>

</div>
</div>
<a id="a3780b7a9cd184d0b4f3ea797eba9e2b3" name="a3780b7a9cd184d0b4f3ea797eba9e2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3780b7a9cd184d0b4f3ea797eba9e2b3">&#9670;&#160;</a></span>maxCoeff() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation, typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::maxCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>rowId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>colId</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum of all coefficients of *this and puts in *row and *col its location.</dd></dl>
<p>In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </p><dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::minCoeff(IndexType*,IndexType*), <a class="el" href="#a4225b90fcc74f18dd479b401124b3841">DenseBase::visit()</a>, <a class="el" href="#a7e6987d106f1cca3ac6ab36d288cc8e1">DenseBase::maxCoeff()</a> </dd></dl>

</div>
</div>
<a id="a21ac6c0419a72ad7a88ea0bc189017d7" name="a21ac6c0419a72ad7a88ea0bc189017d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ac6c0419a72ad7a88ea0bc189017d7">&#9670;&#160;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::mean </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the mean of all coefficients of *this</dd></dl>
<dl class="section see"><dt>See also</dt><dd>trace(), <a class="el" href="#af119d9a4efe5a15cd83c1ccdf01b3a4f">prod()</a>, <a class="el" href="#addd7080d5c202795820e361768d0140c">sum()</a> </dd></dl>

</div>
</div>
<a id="a0739f9c868c331031c7810e21838dcb2" name="a0739f9c868c331031c7810e21838dcb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0739f9c868c331031c7810e21838dcb2">&#9670;&#160;</a></span>minCoeff() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::minCoeff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum of all coefficients of <code>*this</code>. In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is minimum of elements that are not NaN </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered. </dd></dl>

</div>
</div>
<a id="ac9265f4f91430b9cc75d63fb6865bb29" name="ac9265f4f91430b9cc75d63fb6865bb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9265f4f91430b9cc75d63fb6865bb29">&#9670;&#160;</a></span>minCoeff() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation, typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::minCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum of all coefficients of *this and puts in *index its location.</dd></dl>
<p>In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </p><dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::maxCoeff(IndexType*,IndexType*), <a class="el" href="#a4225b90fcc74f18dd479b401124b3841">DenseBase::visit()</a>, <a class="el" href="#a0739f9c868c331031c7810e21838dcb2">DenseBase::minCoeff()</a> </dd></dl>

</div>
</div>
<a id="aa28152ba4a42b2d112e5fec5469ec4c1" name="aa28152ba4a42b2d112e5fec5469ec4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28152ba4a42b2d112e5fec5469ec4c1">&#9670;&#160;</a></span>minCoeff() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation, typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::minCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>rowId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>colId</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum of all coefficients of *this and puts in *row and *col its location.</dd></dl>
<p>In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </p><dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::minCoeff(Index*), DenseBase::maxCoeff(Index*,Index*), <a class="el" href="#a4225b90fcc74f18dd479b401124b3841">DenseBase::visit()</a>, <a class="el" href="#a0739f9c868c331031c7810e21838dcb2">DenseBase::minCoeff()</a> </dd></dl>

</div>
</div>
<a id="a3e2761e2b6da74dba1d17b40cc918bf7" name="a3e2761e2b6da74dba1d17b40cc918bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2761e2b6da74dba1d17b40cc918bf7">&#9670;&#160;</a></span>nestByValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::nestByValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the temporary version of *this. </dd></dl>

</div>
</div>
<a id="a5dc65501accd02c30f7c1840c2a30a41" name="a5dc65501accd02c30f7c1840c2a30a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc65501accd02c30f7c1840c2a30a41">&#9670;&#160;</a></span>NullaryExpr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename CustomNullaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, <a class="el" href="#a25f82d9f5a1367f64b9a61df53b836d4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::NullaryExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomNullaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix defined by a custom functor <em>func</em> </dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays.">DenseBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a3340c9b997f5b53a0131cf927f93b54c" name="a3340c9b997f5b53a0131cf927f93b54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3340c9b997f5b53a0131cf927f93b54c">&#9670;&#160;</a></span>NullaryExpr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename CustomNullaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, <a class="el" href="#a25f82d9f5a1367f64b9a61df53b836d4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::NullaryExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomNullaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix defined by a custom functor <em>func</em> </dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a> should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a9752ee59976a4b4aad860ad1a9093e7f" name="a9752ee59976a4b4aad860ad1a9093e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9752ee59976a4b4aad860ad1a9093e7f">&#9670;&#160;</a></span>NullaryExpr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename CustomNullaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, <a class="el" href="#a25f82d9f5a1367f64b9a61df53b836d4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::NullaryExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomNullaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix defined by a custom functor <em>func</em> </dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a> should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<p>Here is an example with C++11 random generators: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  std::default_random_engine generator;</div>
<div class="line">  std::poisson_distribution&lt;int&gt; distribution(4.1);</div>
<div class="line">  <span class="keyword">auto</span> poisson = [&amp;]() { <span class="keywordflow">return</span> distribution(generator); };</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classEigen_1_1Matrix.html">Eigen::RowVectorXi</a> v = <a class="code hl_function" href="#a3340c9b997f5b53a0131cf927f93b54c">Eigen::RowVectorXi::NullaryExpr</a>(10, poisson);</div>
<div class="line">  std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a3340c9b997f5b53a0131cf927f93b54c"><div class="ttname"><a href="#a3340c9b997f5b53a0131cf927f93b54c">Eigen::DenseBase::NullaryExpr</a></div><div class="ttdeci">static const CwiseNullaryOp&lt; CustomNullaryOp, PlainObject &gt; NullaryExpr(Index rows, Index cols, const CustomNullaryOp &amp;func)</div><div class="ttdef"><b>Definition</b> CwiseNullaryOp.h:108</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a2755cb4023f7376880523626a8e05101" name="a2755cb4023f7376880523626a8e05101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2755cb4023f7376880523626a8e05101">&#9670;&#160;</a></span>Ones() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Ones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size matrix or vector where all coefficients equal one.</dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; Matrix2d::Ones() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; 6 * RowVector4i::Ones() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab710a58e4a80fbcb2594242372c8fe56">Ones(Index)</a>, <a class="el" href="#a8b2a51018a73a766f5b91aef3487f013">Ones(Index,Index)</a>, <a class="el" href="#aa56d6b4477cd3c92a9cf42f4b96e47c2">isOnes()</a>, class <a class="el" href="#a8b2a51018a73a766f5b91aef3487f013">Ones</a> </dd></dl>

</div>
</div>
<a id="a8b2a51018a73a766f5b91aef3487f013" name="a8b2a51018a73a766f5b91aef3487f013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2a51018a73a766f5b91aef3487f013">&#9670;&#160;</a></span>Ones() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix where all coefficients equal one.</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="#a2755cb4023f7376880523626a8e05101">Ones()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; MatrixXi::Ones(2, 3) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2755cb4023f7376880523626a8e05101">Ones()</a>, <a class="el" href="#ab710a58e4a80fbcb2594242372c8fe56">Ones(Index)</a>, <a class="el" href="#aa56d6b4477cd3c92a9cf42f4b96e47c2">isOnes()</a>, class <a class="el" href="#a8b2a51018a73a766f5b91aef3487f013">Ones</a> </dd></dl>

</div>
</div>
<a id="ab710a58e4a80fbcb2594242372c8fe56" name="ab710a58e4a80fbcb2594242372c8fe56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab710a58e4a80fbcb2594242372c8fe56">&#9670;&#160;</a></span>Ones() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a vector where all coefficients equal one.</dd></dl>
<p>The parameter <em>newSize</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="#a2755cb4023f7376880523626a8e05101">Ones()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; 6 * RowVectorXi::Ones(4) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXf::Ones(2) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2755cb4023f7376880523626a8e05101">Ones()</a>, <a class="el" href="#a8b2a51018a73a766f5b91aef3487f013">Ones(Index,Index)</a>, <a class="el" href="#aa56d6b4477cd3c92a9cf42f4b96e47c2">isOnes()</a>, class <a class="el" href="#a8b2a51018a73a766f5b91aef3487f013">Ones</a> </dd></dl>

</div>
</div>
<a id="a0f0e34696162b34762b2bf4bd948f90c" name="a0f0e34696162b34762b2bf4bd948f90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0e34696162b34762b2bf4bd948f90c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0e575eb0ba6cc6bc5f347872abd8509d">operator&lt;&lt;(const Scalar&amp;)</a> </dd></dl>

</div>
</div>
<a id="a0e575eb0ba6cc6bc5f347872abd8509d" name="a0e575eb0ba6cc6bc5f347872abd8509d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e575eb0ba6cc6bc5f347872abd8509d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="anchor" id="MatrixBaseCommaInitRef"></a>Convenient operator to set the coefficients of a matrix.</p>
<p>The coefficients must be provided in a row major order and exactly match the size of the matrix. Otherwise an assertion is raised.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3i</a> m1;</div>
<div class="line">m1 &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9;</div>
<div class="line">cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3i</a> m2 = Matrix3i::Identity();</div>
<div class="line">m2.block(0, 0, 2, 2) &lt;&lt; 10, 11, 12, 13;</div>
<div class="line">cout &lt;&lt; m2 &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Vector2i</a> v1;</div>
<div class="line">v1 &lt;&lt; 14, 15;</div>
<div class="line">m2 &lt;&lt; v1.<a class="code hl_function" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose</a>(), 16, v1, m1.block(1, 1, 2, 2);</div>
<div class="line">cout &lt;&lt; m2 &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section note"><dt>Note</dt><dd>According the c++ standard, the argument expressions of this comma initializer are evaluated in arbitrary order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structEigen_1_1CommaInitializer.html#aa16116338bc1575b4b7b7de362aa27d0">CommaInitializer::finished()</a>, class <a class="el" href="structEigen_1_1CommaInitializer.html" title="Helper class used by the comma initializer operator.">CommaInitializer</a> </dd></dl>

</div>
</div>
<a id="a5281dadff89f46eef719b38e5d073a8f" name="a5281dadff89f46eef719b38e5d073a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5281dadff89f46eef719b38e5d073a8f">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Special case of the template operator=, in order to prevent the compiler from generating a default operator= (issue hit with g++ 4.1) </p>

</div>
</div>
<a id="ab66155169d20c035e80d521a8b918e97" name="ab66155169d20c035e80d521a8b918e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66155169d20c035e80d521a8b918e97">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies <em>other</em> into *this. </p><dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a58915510693d64164e567bd762e1032f" name="a58915510693d64164e567bd762e1032f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58915510693d64164e567bd762e1032f">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the generic expression <em>other</em> into *this. </p>
<p>The expression must provide a (templated) evalTo(Derived&amp; dst) const function which does the actual job. In practice, this allows any user to write its own special matrix without having to modify <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a></p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a03f71699bc26ca2ee4e42ec4538862d7" name="a03f71699bc26ca2ee4e42ec4538862d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f71699bc26ca2ee4e42ec4538862d7">&#9670;&#160;</a></span>outerSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::outerSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the outer size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a vector, this returns just 1. For a matrix (non-vector), this is the major dimension with respect to the <a class="el" href="group__TopicStorageOrders.html">storage order</a>, i.e., the number of columns for a column-major matrix, and the number of rows for a row-major matrix. </dd></dl>

</div>
</div>
<a id="af119d9a4efe5a15cd83c1ccdf01b3a4f" name="af119d9a4efe5a15cd83c1ccdf01b3a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af119d9a4efe5a15cd83c1ccdf01b3a4f">&#9670;&#160;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::prod </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the product of all coefficients of *this</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the product of all the coefficients:&quot;</span> &lt;&lt; endl &lt;&lt; m.<a class="code hl_function" href="#af119d9a4efe5a15cd83c1ccdf01b3a4f">prod</a>() &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_af119d9a4efe5a15cd83c1ccdf01b3a4f"><div class="ttname"><a href="#af119d9a4efe5a15cd83c1ccdf01b3a4f">Eigen::DenseBase::prod</a></div><div class="ttdeci">Scalar prod() const</div><div class="ttdef"><b>Definition</b> Redux.h:510</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#addd7080d5c202795820e361768d0140c">sum()</a>, <a class="el" href="#a21ac6c0419a72ad7a88ea0bc189017d7">mean()</a>, trace() </dd></dl>

</div>
</div>
<a id="ae814abb451b48ed872819192dc188c19" name="ae814abb451b48ed872819192dc188c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae814abb451b48ed872819192dc188c19">&#9670;&#160;</a></span>Random() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Random </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size random matrix or vector expression</dd></dl>
<p>Numbers are uniformly spread through their whole definition range for integer types, and in the [-1:1] range for floating point scalar types.</p>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; 100 * Matrix2i::Random() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary matrix whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not re-entrant.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac476e5852129ba32beaa1a8a3d7ee0db">DenseBase::setRandom()</a>, <a class="el" href="#ae97f8d9d08f969c733c8144be6225756">DenseBase::Random(Index,Index)</a>, <a class="el" href="#a7eb5f974a8f0b67eac7080db1da0e308">DenseBase::Random(Index)</a> </dd></dl>

</div>
</div>
<a id="ae97f8d9d08f969c733c8144be6225756" name="ae97f8d9d08f969c733c8144be6225756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97f8d9d08f969c733c8144be6225756">&#9670;&#160;</a></span>Random() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a random matrix expression</dd></dl>
<p>Numbers are uniformly spread through their whole definition range for integer types, and in the [-1:1] range for floating point scalar types.</p>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not re-entrant.</dd></dl>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="#ae814abb451b48ed872819192dc188c19">Random()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; MatrixXi::Random(2, 3) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary matrix whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<p>See <a class="el" href="#a9752ee59976a4b4aad860ad1a9093e7f">DenseBase::NullaryExpr(Index, const CustomNullaryOp&amp;)</a> for an example using C++11 random generators.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac476e5852129ba32beaa1a8a3d7ee0db">DenseBase::setRandom()</a>, <a class="el" href="#a7eb5f974a8f0b67eac7080db1da0e308">DenseBase::Random(Index)</a>, <a class="el" href="#ae814abb451b48ed872819192dc188c19">DenseBase::Random()</a> </dd></dl>

</div>
</div>
<a id="a7eb5f974a8f0b67eac7080db1da0e308" name="a7eb5f974a8f0b67eac7080db1da0e308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb5f974a8f0b67eac7080db1da0e308">&#9670;&#160;</a></span>Random() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a random vector expression</dd></dl>
<p>Numbers are uniformly spread through their whole definition range for integer types, and in the [-1:1] range for floating point scalar types.</p>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column. </p><dl class="section warning"><dt>Warning</dt><dd>This function is not re-entrant.</dd></dl>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="#ae814abb451b48ed872819192dc188c19">Random()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; VectorXi::Random(2) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary vector whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac476e5852129ba32beaa1a8a3d7ee0db">DenseBase::setRandom()</a>, <a class="el" href="#ae97f8d9d08f969c733c8144be6225756">DenseBase::Random(Index,Index)</a>, <a class="el" href="#ae814abb451b48ed872819192dc188c19">DenseBase::Random()</a> </dd></dl>

</div>
</div>
<a id="ad2ab5a8020dcd9d5986cb20d8a7ab213" name="ad2ab5a8020dcd9d5986cb20d8a7ab213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ab5a8020dcd9d5986cb20d8a7ab213">&#9670;&#160;</a></span>redux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::redux </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the result of a full redux operation on the whole matrix or vector using <em>func</em> </dd></dl>
<p>The template parameter <em>BinaryOp</em> is the type of the functor <em>func</em> which must be an associative operator. Both current C++98 and C++11 functor styles are handled.</p>
<dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#addd7080d5c202795820e361768d0140c">DenseBase::sum()</a>, <a class="el" href="#a0739f9c868c331031c7810e21838dcb2">DenseBase::minCoeff()</a>, <a class="el" href="#a7e6987d106f1cca3ac6ab36d288cc8e1">DenseBase::maxCoeff()</a>, <a class="el" href="#a1c0e1b6067ec1de6cb8799da55aa7d30">MatrixBase::colwise()</a>, <a class="el" href="#a6daa3a3156ca0e0722bf78638e1c7f28">MatrixBase::rowwise()</a> </dd></dl>

</div>
</div>
<a id="a60dadfe80b813d808e91e4521c722a8e" name="a60dadfe80b813d808e91e4521c722a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dadfe80b813d808e91e4521c722a8e">&#9670;&#160;</a></span>replicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;int RowFactor, int ColFactor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, RowFactor, ColFactor &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::replicate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">MatrixXi</a> m = MatrixXi::Random(2, 3);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.replicate&lt;3,2&gt;() = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.<a class="code hl_function" href="#a60dadfe80b813d808e91e4521c722a8e">replicate</a>&lt;3, 2&gt;() &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a60dadfe80b813d808e91e4521c722a8e"><div class="ttname"><a href="#a60dadfe80b813d808e91e4521c722a8e">Eigen::DenseBase::replicate</a></div><div class="ttdeci">const Replicate&lt; Derived, RowFactor, ColFactor &gt; replicate() const</div><div class="ttdef"><b>Definition</b> Replicate.h:109</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a5f0c8dc9e9c4aeaa2057f15800f5c18c">VectorwiseOp::replicate()</a>, DenseBase::replicate(Index,Index), class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="a791b725f6109e29a759d623febe56ecd" name="a791b725f6109e29a759d623febe56ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b725f6109e29a759d623febe56ecd">&#9670;&#160;</a></span>replicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rowFactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>colFactor</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Vector3i</a> v = Vector3i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;v.replicate(2,5) = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; v.<a class="code hl_function" href="#a60dadfe80b813d808e91e4521c722a8e">replicate</a>(2, 5) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a5f0c8dc9e9c4aeaa2057f15800f5c18c">VectorwiseOp::replicate()</a>, <a class="el" href="#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate&lt;int,int&gt;()</a>, class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="a2ec5bac4e1ab95808808ef50ccf4cb39" name="a2ec5bac4e1ab95808808ef50ccf4cb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec5bac4e1ab95808808ef50ccf4cb39">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are <a class="el" href="#a2ec5bac4e1ab95808808ef50ccf4cb39">Matrix::resize()</a> and <a class="el" href="#a2ec5bac4e1ab95808808ef50ccf4cb39">Array::resize()</a>. The present method only asserts that the new size equals the old size, and does nothing else. </p>

</div>
</div>
<a id="a25e2b4887b47b1f2346857d1931efa0f" name="a25e2b4887b47b1f2346857d1931efa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e2b4887b47b1f2346857d1931efa0f">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are <a class="el" href="#a2ec5bac4e1ab95808808ef50ccf4cb39">Matrix::resize()</a> and <a class="el" href="#a2ec5bac4e1ab95808808ef50ccf4cb39">Array::resize()</a>. The present method only asserts that the new size equals the old size, and does nothing else. </p>

</div>
</div>
<a id="a38ea394036d8b096abf322469c80198f" name="a38ea394036d8b096abf322469c80198f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ea394036d8b096abf322469c80198f">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ReverseReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the reverse of *this.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">MatrixXi</a> m = MatrixXi::Random(3, 4);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.<a class="code hl_function" href="#a38ea394036d8b096abf322469c80198f">reverse</a>() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the coefficient (1,0) in the reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.<a class="code hl_function" href="#a38ea394036d8b096abf322469c80198f">reverse</a>()(1, 0) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Let us overwrite this coefficient with the value 4.&quot;</span> &lt;&lt; endl;</div>
<div class="line">m.<a class="code hl_function" href="#a38ea394036d8b096abf322469c80198f">reverse</a>()(1, 0) = 4;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a38ea394036d8b096abf322469c80198f"><div class="ttname"><a href="#a38ea394036d8b096abf322469c80198f">Eigen::DenseBase::reverse</a></div><div class="ttdeci">ReverseReturnType reverse()</div><div class="ttdef"><b>Definition</b> Reverse.h:110</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> 
</div>
</div>
<a id="a9e2f3ac4019184abf95ca0e1a8d82866" name="a9e2f3ac4019184abf95ca0e1a8d82866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2f3ac4019184abf95ca0e1a8d82866">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="#a38ea394036d8b096abf322469c80198f">reverse()</a>. </p>

</div>
</div>
<a id="adb8045155ea45f7961fc2a5170e1d921" name="adb8045155ea45f7961fc2a5170e1d921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8045155ea45f7961fc2a5170e1d921">&#9670;&#160;</a></span>reverseInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::reverseInPlace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of reverse: it reverses <code>*this</code>.</p>
<p>In most cases it is probably better to simply use the reversed expression of a matrix. However, when reversing the matrix data itself is really needed, then this "in-place" version is probably the right choice because it provides the following additional benefits:</p><ul>
<li>less error prone: doing the same operation with .<a class="el" href="#a38ea394036d8b096abf322469c80198f">reverse()</a> requires special care: <div class="fragment"><div class="line">m = m.reverse().eval(); </div>
</div><!-- fragment --></li>
<li>this API enables reverse operations without the need for a temporary</li>
<li>it allows future optimizations (cache friendliness, etc.)</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#ab9dd7c273eb2ba8defaab2d55156936b">VectorwiseOp::reverseInPlace()</a>, <a class="el" href="#a38ea394036d8b096abf322469c80198f">reverse()</a> </dd></dl>

</div>
</div>
<a id="a6daa3a3156ca0e0722bf78638e1c7f28" name="a6daa3a3156ca0e0722bf78638e1c7f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6daa3a3156ca0e0722bf78638e1c7f28">&#9670;&#160;</a></span>rowwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RowwiseReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::rowwise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a> wrapper of *this providing additional partial reduction operations</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a58837c81de446efbdb58da07b73a63c1">colwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, <a class="el" href="group__TutorialReductionsVisitorsBroadcasting.html">Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a id="aa1cabd3404528fe8cec4bab43d74bffc" name="aa1cabd3404528fe8cec4bab43d74bffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cabd3404528fe8cec4bab43d74bffc">&#9670;&#160;</a></span>rowwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html">ConstRowwiseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::rowwise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a> wrapper of *this for broadcasting and partial reductions</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.<a class="code hl_function" href="#aa1cabd3404528fe8cec4bab43d74bffc">rowwise</a>().<a class="code hl_function" href="classEigen_1_1VectorwiseOp.html#a7030fc687c24d687ed7cd70733ba611c">sum</a>() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum absolute value of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.cwiseAbs().<a class="code hl_function" href="#aa1cabd3404528fe8cec4bab43d74bffc">rowwise</a>().<a class="code hl_function" href="classEigen_1_1VectorwiseOp.html#a6646b584db116c1661b5bb56750bd6f6">maxCoeff</a>() &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_aa1cabd3404528fe8cec4bab43d74bffc"><div class="ttname"><a href="#aa1cabd3404528fe8cec4bab43d74bffc">Eigen::DenseBase::rowwise</a></div><div class="ttdeci">ConstRowwiseReturnType rowwise() const</div><div class="ttdef"><b>Definition</b> DenseBase.h:501</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a58837c81de446efbdb58da07b73a63c1">colwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, <a class="el" href="group__TutorialReductionsVisitorsBroadcasting.html">Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a id="ae565bdc9af5d0d7d6f86eeceefa0041f" name="ae565bdc9af5d0d7d6f86eeceefa0041f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae565bdc9af5d0d7d6f86eeceefa0041f">&#9670;&#160;</a></span>select() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename ThenDerived , typename ElseDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseTernaryOp.html">CwiseTernaryOp</a>&lt; internal::scalar_boolean_select_op&lt; typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &gt;, ThenDerived, ElseDerived, Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>thenMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elseMatrix</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a matrix where each coefficient (i,j) is equal to <em>thenMatrix(i,j)</em> if <code>*this</code>(i,j) != <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar(0)</a>, and <em>elseMatrix(i,j)</em> otherwise.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">MatrixXi</a> m(3, 3);</div>
<div class="line">m &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9;</div>
<div class="line">m = (m.array() &gt;= 5).select(-m, m);</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>DenseBase::bitwiseSelect(const DenseBase&lt;ThenDerived&gt;&amp;, const DenseBase&lt;ElseDerived&gt;&amp;) </dd></dl>

</div>
</div>
<a id="af1f6127ef2e8edf0603624df9181f0d5" name="af1f6127ef2e8edf0603624df9181f0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f6127ef2e8edf0603624df9181f0d5">&#9670;&#160;</a></span>select() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename ThenDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseTernaryOp.html">CwiseTernaryOp</a>&lt; internal::scalar_boolean_select_op&lt; typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &gt;, ThenDerived, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;::ConstantReturnType, Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>thenMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>elseScalar</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Version of DenseBase::select(const DenseBase&amp;, const DenseBase&amp;) with the <em>else</em> expression being a scalar value.</p>
<dl class="section see"><dt>See also</dt><dd>DenseBase::booleanSelect(const DenseBase&lt;ThenDerived&gt;&amp;, const DenseBase&lt;ElseDerived&gt;&amp;) const, class <a class="el" href="classEigen_1_1Select.html" title="Expression of a coefficient wise version of the C++ ternary operator ?:">Select</a> </dd></dl>

</div>
</div>
<a id="a9032b8ef4c81be6b61a89beaff1fa248" name="a9032b8ef4c81be6b61a89beaff1fa248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9032b8ef4c81be6b61a89beaff1fa248">&#9670;&#160;</a></span>select() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename ElseDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseTernaryOp.html">CwiseTernaryOp</a>&lt; internal::scalar_boolean_select_op&lt; typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &gt;, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;::ConstantReturnType, ElseDerived, Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thenScalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elseMatrix</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Version of DenseBase::select(const DenseBase&amp;, const DenseBase&amp;) with the <em>then</em> expression being a scalar value.</p>
<dl class="section see"><dt>See also</dt><dd>DenseBase::booleanSelect(const DenseBase&lt;ThenDerived&gt;&amp;, const DenseBase&lt;ElseDerived&gt;&amp;) const, class <a class="el" href="classEigen_1_1Select.html" title="Expression of a coefficient wise version of the C++ ternary operator ?:">Select</a> </dd></dl>

</div>
</div>
<a id="ac2f1e50d1f567da38da1d2f07c5ab559" name="ac2f1e50d1f567da38da1d2f07c5ab559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f1e50d1f567da38da1d2f07c5ab559">&#9670;&#160;</a></span>setConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to value <em>val</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9be169c308801411aa24be93d30930bf">fill()</a>, setConstant(Index,const Scalar&amp;), setConstant(Index,Index,const Scalar&amp;), <a class="el" href="#af230a143de50695d2d1fae93db7e4dcb">setZero()</a>, <a class="el" href="#a250ef1b827e748f3f898fb2e55cb96e2">setOnes()</a>, <a class="el" href="#a68a7ece6c5629d1e9447a321fcb14ccd">Constant()</a>, class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#af230a143de50695d2d1fae93db7e4dcb">setZero()</a>, <a class="el" href="#a250ef1b827e748f3f898fb2e55cb96e2">setOnes()</a> </dd></dl>

</div>
</div>
<a id="aeb023532476d3f14c457367e0eb5f3f1" name="aeb023532476d3f14c457367e0eb5f3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb023532476d3f14c457367e0eb5f3f1">&#9670;&#160;</a></span>setLinSpaced() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setLinSpaced </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly spaced vector. </p>
<p>The function fills <code>*this</code> with equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>For integer scalar types, do not miss the explanations on the definition of <a class="el" href="#aaef589c1dbd7fad93f97bd3fa1b1e768">even spacing </a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aaef589c1dbd7fad93f97bd3fa1b1e768" title="Sets a linearly spaced vector.">LinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, <a class="el" href="#a5d1ce9e801fa502e02b9b8cd9141ad0a" title="Sets a linearly spaced vector.">setLinSpaced(Index, const Scalar&amp;, const Scalar&amp;)</a>, <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a5d1ce9e801fa502e02b9b8cd9141ad0a" name="a5d1ce9e801fa502e02b9b8cd9141ad0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1ce9e801fa502e02b9b8cd9141ad0a">&#9670;&#160;</a></span>setLinSpaced() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setLinSpaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>newSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly spaced vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">VectorXf</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a5d1ce9e801fa502e02b9b8cd9141ad0a">setLinSpaced</a>(5, 0.5f, 1.5f);</div>
<div class="line">cout &lt;&lt; v &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a5d1ce9e801fa502e02b9b8cd9141ad0a"><div class="ttname"><a href="#a5d1ce9e801fa502e02b9b8cd9141ad0a">Eigen::DenseBase::setLinSpaced</a></div><div class="ttdeci">Derived &amp; setLinSpaced(Index size, const Scalar &amp;low, const Scalar &amp;high)</div><div class="ttdoc">Sets a linearly spaced vector.</div><div class="ttdef"><b>Definition</b> CwiseNullaryOp.h:427</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>For integer scalar types, do not miss the explanations on the definition of <a class="el" href="#aaef589c1dbd7fad93f97bd3fa1b1e768">even spacing </a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aaef589c1dbd7fad93f97bd3fa1b1e768" title="Sets a linearly spaced vector.">LinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a250ef1b827e748f3f898fb2e55cb96e2" name="a250ef1b827e748f3f898fb2e55cb96e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250ef1b827e748f3f898fb2e55cb96e2">&#9670;&#160;</a></span>setOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setOnes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to one.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix4i</a> m = Matrix4i::Random();</div>
<div class="line">m.row(1).<a class="code hl_function" href="classEigen_1_1PlainObjectBase.html#a8700dc6d8e05436c0b34ae15ca9274a5">setOnes</a>();</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1PlainObjectBase_html_a8700dc6d8e05436c0b34ae15ca9274a5"><div class="ttname"><a href="classEigen_1_1PlainObjectBase.html#a8700dc6d8e05436c0b34ae15ca9274a5">Eigen::PlainObjectBase::setOnes</a></div><div class="ttdeci">Derived &amp; setOnes(Index size)</div><div class="ttdef"><b>Definition</b> CwiseNullaryOp.h:702</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#a2755cb4023f7376880523626a8e05101">Ones()</a> </dd></dl>

</div>
</div>
<a id="ac476e5852129ba32beaa1a8a3d7ee0db" name="ac476e5852129ba32beaa1a8a3d7ee0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac476e5852129ba32beaa1a8a3d7ee0db">&#9670;&#160;</a></span>setRandom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setRandom </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to random values.</p>
<p>Numbers are uniformly spread through their whole definition range for integer types, and in the [-1:1] range for floating point scalar types.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not re-entrant.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix4i</a> m = Matrix4i::Zero();</div>
<div class="line">m.col(1).<a class="code hl_function" href="classEigen_1_1PlainObjectBase.html#a5f0f6cc8039ed5ac026cd32ed5bbe6ea">setRandom</a>();</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1PlainObjectBase_html_a5f0f6cc8039ed5ac026cd32ed5bbe6ea"><div class="ttname"><a href="classEigen_1_1PlainObjectBase.html#a5f0f6cc8039ed5ac026cd32ed5bbe6ea">Eigen::PlainObjectBase::setRandom</a></div><div class="ttdeci">Derived &amp; setRandom(Index size)</div><div class="ttdef"><b>Definition</b> Random.h:147</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, setRandom(Index), setRandom(Index,Index) </dd></dl>

</div>
</div>
<a id="af230a143de50695d2d1fae93db7e4dcb" name="af230a143de50695d2d1fae93db7e4dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af230a143de50695d2d1fae93db7e4dcb">&#9670;&#160;</a></span>setZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to zero.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix4i</a> m = Matrix4i::Random();</div>
<div class="line">m.row(1).<a class="code hl_function" href="classEigen_1_1PlainObjectBase.html#acc39eaf7ba22b725c86f1b9b8bb57c3c">setZero</a>();</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1PlainObjectBase_html_acc39eaf7ba22b725c86f1b9b8bb57c3c"><div class="ttname"><a href="classEigen_1_1PlainObjectBase.html#acc39eaf7ba22b725c86f1b9b8bb57c3c">Eigen::PlainObjectBase::setZero</a></div><div class="ttdeci">Derived &amp; setZero(Index size)</div><div class="ttdef"><b>Definition</b> CwiseNullaryOp.h:563</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a> </dd></dl>

</div>
</div>
<a id="addd7080d5c202795820e361768d0140c" name="addd7080d5c202795820e361768d0140c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd7080d5c202795820e361768d0140c">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::sum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of all coefficients of <code>*this</code> </dd></dl>
<p>If <code>*this</code> is empty, then the value 0 is returned.</p>
<dl class="section see"><dt>See also</dt><dd>trace(), <a class="el" href="#af119d9a4efe5a15cd83c1ccdf01b3a4f">prod()</a>, <a class="el" href="#a21ac6c0419a72ad7a88ea0bc189017d7">mean()</a> </dd></dl>

</div>
</div>
<a id="af9e7e4305fdb7781f2b2f05fa801f21e" name="af9e7e4305fdb7781f2b2f05fa801f21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e7e4305fdb7781f2b2f05fa801f21e">&#9670;&#160;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>swaps *this with the expression <em>other</em>. </p>

</div>
</div>
<a id="a44e25adc6da9cd1d79f4c5bd7c1819cb" name="a44e25adc6da9cd1d79f4c5bd7c1819cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e25adc6da9cd1d79f4c5bd7c1819cb">&#9670;&#160;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>swaps *this with the matrix or array <em>other</em>. </p>

</div>
</div>
<a id="a43cbcd866a0737eb56642c2e992f0afd" name="a43cbcd866a0737eb56642c2e992f0afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cbcd866a0737eb56642c2e992f0afd">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::TransposeReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the transpose of *this.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix2i</a> m = Matrix2i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the transpose of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.<a class="code hl_function" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose</a>() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the coefficient (1,0) in the transpose of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.<a class="code hl_function" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose</a>()(1, 0) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Let us overwrite this coefficient with the value 0.&quot;</span> &lt;&lt; endl;</div>
<div class="line">m.<a class="code hl_function" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose</a>()(1, 0) = 0;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section warning"><dt>Warning</dt><dd>If you want to replace a matrix by its own transpose, do <b>NOT</b> do this: <div class="fragment"><div class="line">m = m.transpose(); <span class="comment">// bug!!! caused by aliasing effect</span></div>
</div><!-- fragment --> Instead, use the <a class="el" href="#ac501bd942994af7a95d95bee7a16ad2a">transposeInPlace()</a> method: <div class="fragment"><div class="line">m.transposeInPlace();</div>
</div><!-- fragment --> which gives <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> good opportunities for optimization, or alternatively you can also do: <div class="fragment"><div class="line">m = m.transpose().eval();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac501bd942994af7a95d95bee7a16ad2a">transposeInPlace()</a>, adjoint() </dd></dl>

</div>
</div>
<a id="a59eb71a8633da26de5e3e03351b2291e" name="a59eb71a8633da26de5e3e03351b2291e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59eb71a8633da26de5e3e03351b2291e">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstTransposeReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose()</a>.</p>
<p>Make sure you read the warning for <a class="el" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose()</a> !</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac501bd942994af7a95d95bee7a16ad2a">transposeInPlace()</a>, adjoint() </dd></dl>

</div>
</div>
<a id="ac501bd942994af7a95d95bee7a16ad2a" name="ac501bd942994af7a95d95bee7a16ad2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac501bd942994af7a95d95bee7a16ad2a">&#9670;&#160;</a></span>transposeInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::transposeInPlace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of <a class="el" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose()</a>: it replaces <code>*this</code> by its own transpose. Thus, doing </p><div class="fragment"><div class="line">m.transposeInPlace();</div>
</div><!-- fragment --><p> has the same effect on m as doing </p><div class="fragment"><div class="line">m = m.transpose().eval();</div>
</div><!-- fragment --><p> and is faster and also safer because in the latter line of code, forgetting the <a class="el" href="#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval()</a> results in a bug caused by <a class="el" href="group__TopicAliasing.html">aliasing</a>.</p>
<p>Notice however that this method is only useful if you want to replace a matrix by its own transpose. If you just need the transpose of a matrix, use <a class="el" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>if the matrix is not square, then <code>*this</code> must be a resizable matrix. This excludes (non-square) fixed-size matrices, block-expressions and maps.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a43cbcd866a0737eb56642c2e992f0afd">transpose()</a>, adjoint(), adjointInPlace() </dd></dl>

</div>
</div>
<a id="a8515f719046aa4851e385661f45595b0" name="a8515f719046aa4851e385661f45595b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8515f719046aa4851e385661f45595b0">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoeffReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the unique coefficient of a 1x1 expression </dd></dl>

</div>
</div>
<a id="a4225b90fcc74f18dd479b401124b3841" name="a4225b90fcc74f18dd479b401124b3841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4225b90fcc74f18dd479b401124b3841">&#9670;&#160;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;</td>          <td class="paramname"><span class="paramname"><em>visitor</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the visitor <em>visitor</em> to the whole coefficients of the matrix or vector.</p>
<p>The template parameter <em>Visitor</em> is the type of the visitor and provides the following interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyVisitor {</div>
<div class="line">  <span class="comment">// called for the first coefficient</span></div>
<div class="line">  <span class="keywordtype">void</span> init(<span class="keyword">const</span> <a class="code hl_typedef" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; value, <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i, <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> j);</div>
<div class="line">  <span class="comment">// called for all other coefficients</span></div>
<div class="line">  <span class="keywordtype">void</span> operator() (<span class="keyword">const</span> <a class="code hl_typedef" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; value, <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i, <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> j);</div>
<div class="line">};</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a5feed465b3a8e60c47e73ecce83e39a2"><div class="ttname"><a href="#a5feed465b3a8e60c47e73ecce83e39a2">Eigen::DenseBase::Scalar</a></div><div class="ttdeci">internal::traits&lt; Derived &gt;::Scalar Scalar</div><div class="ttdef"><b>Definition</b> DenseBase.h:62</div></div>
<div class="ttc" id="anamespaceEigen_html_a62e77e0933482dafde8fe197d9a2cfde"><div class="ttname"><a href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a></div><div class="ttdeci">EIGEN_DEFAULT_DENSE_INDEX_TYPE Index</div><div class="ttdoc">The Index type as used for the API.</div><div class="ttdef"><b>Definition</b> Meta.h:83</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>compared to one or two <em>for</em> <em>loops</em>, visitors offer automatic unrolling for small fixed size matrix.</dd>
<dd>
if the matrix is empty, then the visitor is left unchanged.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>minCoeff(Index*,Index*), maxCoeff(Index*,Index*), DenseBase::redux() </dd></dl>

</div>
</div>
<a id="a422ddeef58bedc7bddb1d4357688d761" name="a422ddeef58bedc7bddb1d4357688d761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422ddeef58bedc7bddb1d4357688d761">&#9670;&#160;</a></span>Zero() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Zero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size zero matrix or vector.</dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; Matrix2d::Zero() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; RowVector4i::Zero() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac22f79b812fa564061042407f2ba8f5b">Zero(Index)</a>, <a class="el" href="#ae41a9b5050ed27d9e93c82c9c8622cd3">Zero(Index,Index)</a> </dd></dl>

</div>
</div>
<a id="ae41a9b5050ed27d9e93c82c9c8622cd3" name="ae41a9b5050ed27d9e93c82c9c8622cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41a9b5050ed27d9e93c82c9c8622cd3">&#9670;&#160;</a></span>Zero() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a zero matrix.</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; MatrixXi::Zero(2, 3) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a>, <a class="el" href="#ac22f79b812fa564061042407f2ba8f5b">Zero(Index)</a> </dd></dl>

</div>
</div>
<a id="ac22f79b812fa564061042407f2ba8f5b" name="ac22f79b812fa564061042407f2ba8f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22f79b812fa564061042407f2ba8f5b">&#9670;&#160;</a></span>Zero() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a zero vector.</dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; RowVectorXi::Zero(4) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; VectorXf::Zero(2) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a422ddeef58bedc7bddb1d4357688d761">Zero()</a>, <a class="el" href="#ae41a9b5050ed27d9e93c82c9c8622cd3">Zero(Index,Index)</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a3806d3f42de165878dace160e6aba40a" name="a3806d3f42de165878dace160e6aba40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3806d3f42de165878dace160e6aba40a">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outputs the matrix, to the given stream.</p>
<p>If you wish to print the matrix with a format different than the default, use <a class="el" href="#a148e20e32aa3ceca13e0a49c2cc584fc">DenseBase::format()</a>.</p>
<p>It is also possible to change the default format by defining EIGEN_DEFAULT_IO_FORMAT before including <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> headers. If not defined, this will automatically be defined to <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed.">Eigen::IOFormat()</a>, that is the <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed.">Eigen::IOFormat</a> with default parameters.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a148e20e32aa3ceca13e0a49c2cc584fc">DenseBase::format()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="DenseBase_8h_source.html">DenseBase.h</a></li>
<li><a class="el" href="Assign_8h_source.html">Assign.h</a></li>
<li><a class="el" href="CommaInitializer_8h_source.html">CommaInitializer.h</a></li>
<li><a class="el" href="CwiseNullaryOp_8h_source.html">CwiseNullaryOp.h</a></li>
<li><a class="el" href="EigenBase_8h_source.html">EigenBase.h</a></li>
<li><a class="el" href="Fuzzy_8h_source.html">Fuzzy.h</a></li>
<li><a class="el" href="IO_8h_source.html">IO.h</a></li>
<li><a class="el" href="NestByValue_8h_source.html">NestByValue.h</a></li>
<li><a class="el" href="Random_8h_source.html">Random.h</a></li>
<li><a class="el" href="Redux_8h_source.html">Redux.h</a></li>
<li><a class="el" href="Replicate_8h_source.html">Replicate.h</a></li>
<li><a class="el" href="ReturnByValue_8h_source.html">ReturnByValue.h</a></li>
<li><a class="el" href="Reverse_8h_source.html">Reverse.h</a></li>
<li><a class="el" href="Select_8h_source.html">Select.h</a></li>
<li><a class="el" href="SelfCwiseBinaryOp_8h_source.html">SelfCwiseBinaryOp.h</a></li>
<li><a class="el" href="StlIterators_8h_source.html">StlIterators.h</a></li>
<li><a class="el" href="Transpose_8h_source.html">Transpose.h</a></li>
<li><a class="el" href="VectorwiseOp_8h_source.html">VectorwiseOp.h</a></li>
<li><a class="el" href="Visitor_8h_source.html">Visitor.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a></li>
    <li class="footer">Generated on Mon Sep 23 2024 01:14:46 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
