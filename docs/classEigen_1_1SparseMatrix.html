<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Eigen::SparseMatrix&lt; Scalar_, Flags_, StorageIndex_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.4.90 (git rev 2d4c9b400cca33d2f5cf316efc7151236244edb1)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classEigen_1_1SparseMatrix.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="classEigen_1_1SparseMatrix-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">Eigen::SparseMatrix&lt; Scalar_, Flags_, StorageIndex_ &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Sparse__chapter.html">Sparse linear algebra</a> &raquo; <a class="el" href="group__Sparse__Reference.html">Reference</a> &raquo; <a class="el" href="group__SparseCore__Module.html">SparseCore module</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Scalar_, int Flags_ = 0, typename StorageIndex_ = int&gt;<br />
class Eigen::SparseMatrix&lt; Scalar_, Flags_, StorageIndex_ &gt;</div><p>A versatible sparse matrix representation. </p>
<p>This class implements a more versatile variants of the common <em>compressed</em> row/column storage format. Each colmun's (resp. row) non zeros are stored as a pair of value with associated row (resp. colmiun) index. All the non zeros are stored in a single large buffer. Unlike the <em>compressed</em> format, there might be extra space in between the nonzeros of two successive colmuns (resp. rows) such that insertion of new non-zero can be done with limited memory reallocation and copies.</p>
<p>A call to the function <a class="el" href="#a12a042a1c981a6421e25f9a1e6dd6571">makeCompressed()</a> turns the matrix into the standard <em>compressed</em> format compatible with many library.</p>
<p>More details on this storage sceheme are given in the <a class="el" href="group__TutorialSparse.html">manual pages</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>the scalar type, i.e. the type of the coefficients </td></tr>
    <tr><td class="paramname">Options_</td><td>Union of bit flags controlling the storage scheme. Currently the only possibility is ColMajor or RowMajor. The default is 0 which means column-major. </td></tr>
    <tr><td class="paramname">StorageIndex_</td><td>the type of the indices. It has to be a <b>signed</b> type (e.g., short, int, std::ptrdiff_t). Default is <code>int</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>In Eigen 3.2, the undocumented type <code><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">SparseMatrix::Index</a></code> was improperly defined as the storage index type (e.g., int), whereas it is now (starting from Eigen 3.3) deprecated and always defined as <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Eigen::Index</a>. Codes making use of <code><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">SparseMatrix::Index</a></code>, might thus likely have to be changed to use <code><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">SparseMatrix::StorageIndex</a></code> instead.</dd></dl>
<p>This class can be extended with the help of the plugin mechanism described on the page <a class="el" href="TopicCustomizing_Plugins.html">Extending MatrixBase (and other classes)</a> by defining the preprocessor symbol <code>EIGEN_SPARSEMATRIX_PLUGIN</code>. </p>
</div><div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Eigen::SparseMatrix&lt; Scalar_, Flags_, StorageIndex_ &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classEigen_1_1SparseMatrix__inherit__graph.png" border="0" usemap="#aEigen_1_1SparseMatrix_3_01Scalar___00_01Flags___00_01StorageIndex___01_4_inherit__map" alt="Inheritance graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d58dec51f8325bd203a9fb2f3f288f1" id="r_a9d58dec51f8325bd203a9fb2f3f288f1"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d58dec51f8325bd203a9fb2f3f288f1">coeff</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col) const</td></tr>
<tr class="separator:a9d58dec51f8325bd203a9fb2f3f288f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb57000a80870035263c87afe6da8d7" id="r_a4bb57000a80870035263c87afe6da8d7"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bb57000a80870035263c87afe6da8d7">coeffRef</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:a4bb57000a80870035263c87afe6da8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f948d44f9dbb7d156755592722f778a" id="r_a2f948d44f9dbb7d156755592722f778a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f948d44f9dbb7d156755592722f778a">cols</a> () const</td></tr>
<tr class="separator:a2f948d44f9dbb7d156755592722f778a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5792eed86aa5e34b949f112f456f0d" id="r_a7d5792eed86aa5e34b949f112f456f0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d5792eed86aa5e34b949f112f456f0d">conservativeResize</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="#a5b7c78810cadca82fecf5006b096a1c4">rows</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="#a2f948d44f9dbb7d156755592722f778a">cols</a>)</td></tr>
<tr class="separator:a7d5792eed86aa5e34b949f112f456f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4032edc53a1c79ef3aa6dfe1d7b400c" id="r_af4032edc53a1c79ef3aa6dfe1d7b400c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Diagonal.html">DiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4032edc53a1c79ef3aa6dfe1d7b400c">diagonal</a> ()</td></tr>
<tr class="separator:af4032edc53a1c79ef3aa6dfe1d7b400c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b1325c3ebe1e7ef2e547917e33d055" id="r_a95b1325c3ebe1e7ef2e547917e33d055"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Diagonal.html">ConstDiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95b1325c3ebe1e7ef2e547917e33d055">diagonal</a> () const</td></tr>
<tr class="separator:a95b1325c3ebe1e7ef2e547917e33d055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d48c2794ae0e6348928152e3929b49" id="r_a23d48c2794ae0e6348928152e3929b49"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23d48c2794ae0e6348928152e3929b49">findOrInsertCoeff</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col, bool *inserted)</td></tr>
<tr class="separator:a23d48c2794ae0e6348928152e3929b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e39927097b34d15a08a41f8ab130cb" id="r_a94e39927097b34d15a08a41f8ab130cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94e39927097b34d15a08a41f8ab130cb">innerIndexPtr</a> ()</td></tr>
<tr class="separator:a94e39927097b34d15a08a41f8ab130cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a048622e2c86790cd33836af6d5eb6f" id="r_a1a048622e2c86790cd33836af6d5eb6f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a048622e2c86790cd33836af6d5eb6f">innerIndexPtr</a> () const</td></tr>
<tr class="separator:a1a048622e2c86790cd33836af6d5eb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6423d60110f5aed0bc9d693c6245da4c" id="r_a6423d60110f5aed0bc9d693c6245da4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6423d60110f5aed0bc9d693c6245da4c">innerNonZeroPtr</a> ()</td></tr>
<tr class="separator:a6423d60110f5aed0bc9d693c6245da4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c15bd5763aaa9cbf0e619610ec4a0e8" id="r_a5c15bd5763aaa9cbf0e619610ec4a0e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c15bd5763aaa9cbf0e619610ec4a0e8">innerNonZeroPtr</a> () const</td></tr>
<tr class="separator:a5c15bd5763aaa9cbf0e619610ec4a0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f8b9e657a05468dcaae1446ec2a6fc" id="r_a93f8b9e657a05468dcaae1446ec2a6fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93f8b9e657a05468dcaae1446ec2a6fc">innerSize</a> () const</td></tr>
<tr class="separator:a93f8b9e657a05468dcaae1446ec2a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d8f72ff86a300b76f9edd67df8d8fd" id="r_ae2d8f72ff86a300b76f9edd67df8d8fd"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d8f72ff86a300b76f9edd67df8d8fd">insert</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:ae2d8f72ff86a300b76f9edd67df8d8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5983337b43e23cf688a00a23e30cfffb" id="r_a5983337b43e23cf688a00a23e30cfffb"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators &gt; </td></tr>
<tr class="memitem:a5983337b43e23cf688a00a23e30cfffb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5983337b43e23cf688a00a23e30cfffb">insertFromSortedTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end)</td></tr>
<tr class="separator:a5983337b43e23cf688a00a23e30cfffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f17d24f224a1fb73ab903e2a42aba4" id="r_a29f17d24f224a1fb73ab903e2a42aba4"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators , typename DupFunctor &gt; </td></tr>
<tr class="memitem:a29f17d24f224a1fb73ab903e2a42aba4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29f17d24f224a1fb73ab903e2a42aba4">insertFromSortedTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end, DupFunctor dup_func)</td></tr>
<tr class="separator:a29f17d24f224a1fb73ab903e2a42aba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bf43559efce09f5415d6b66aa31d53" id="r_af5bf43559efce09f5415d6b66aa31d53"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators &gt; </td></tr>
<tr class="memitem:af5bf43559efce09f5415d6b66aa31d53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5bf43559efce09f5415d6b66aa31d53">insertFromTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end)</td></tr>
<tr class="separator:af5bf43559efce09f5415d6b66aa31d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452919fafc44dc6f8407fe4e5ffeddd" id="r_ab452919fafc44dc6f8407fe4e5ffeddd"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators , typename DupFunctor &gt; </td></tr>
<tr class="memitem:ab452919fafc44dc6f8407fe4e5ffeddd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab452919fafc44dc6f8407fe4e5ffeddd">insertFromTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end, DupFunctor dup_func)</td></tr>
<tr class="separator:ab452919fafc44dc6f8407fe4e5ffeddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837934b33a80fe996ff20500373d3a61" id="r_a837934b33a80fe996ff20500373d3a61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a837934b33a80fe996ff20500373d3a61">isCompressed</a> () const</td></tr>
<tr class="separator:a837934b33a80fe996ff20500373d3a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a042a1c981a6421e25f9a1e6dd6571" id="r_a12a042a1c981a6421e25f9a1e6dd6571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12a042a1c981a6421e25f9a1e6dd6571">makeCompressed</a> ()</td></tr>
<tr class="separator:a12a042a1c981a6421e25f9a1e6dd6571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03de8b3da2c142ce8698a76123b3e7d3" id="r_a03de8b3da2c142ce8698a76123b3e7d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03de8b3da2c142ce8698a76123b3e7d3">nonZeros</a> () const</td></tr>
<tr class="separator:a03de8b3da2c142ce8698a76123b3e7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d9e4e0d99997f46db7d90cab141b27" id="r_a52d9e4e0d99997f46db7d90cab141b27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52d9e4e0d99997f46db7d90cab141b27">outerIndexPtr</a> ()</td></tr>
<tr class="separator:a52d9e4e0d99997f46db7d90cab141b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aaff931f31ce89c1af572ff9cc40f3" id="r_ac3aaff931f31ce89c1af572ff9cc40f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3aaff931f31ce89c1af572ff9cc40f3">outerIndexPtr</a> () const</td></tr>
<tr class="separator:ac3aaff931f31ce89c1af572ff9cc40f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609a0a5e82d875b49135b28b519ed32c" id="r_a609a0a5e82d875b49135b28b519ed32c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a609a0a5e82d875b49135b28b519ed32c">outerSize</a> () const</td></tr>
<tr class="separator:a609a0a5e82d875b49135b28b519ed32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d324253a9bc6cffe9a090c8a6b07be" id="r_aa5d324253a9bc6cffe9a090c8a6b07be"><td class="memTemplParams" colspan="2">template&lt;typename KeepFunc &gt; </td></tr>
<tr class="memitem:aa5d324253a9bc6cffe9a090c8a6b07be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5d324253a9bc6cffe9a090c8a6b07be">prune</a> (const KeepFunc &amp;keep=KeepFunc())</td></tr>
<tr class="separator:aa5d324253a9bc6cffe9a090c8a6b07be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc29889aed7b071d7a4066349466f0" id="r_a2fdc29889aed7b071d7a4066349466f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fdc29889aed7b071d7a4066349466f0">prune</a> (const Scalar &amp;reference, const RealScalar &amp;epsilon=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; RealScalar &gt;::dummy_precision())</td></tr>
<tr class="separator:a2fdc29889aed7b071d7a4066349466f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282c59eda2b3dc7f4d7eef4e1da9ce5a" id="r_a282c59eda2b3dc7f4d7eef4e1da9ce5a"><td class="memTemplParams" colspan="2">template&lt;class SizesType &gt; </td></tr>
<tr class="memitem:a282c59eda2b3dc7f4d7eef4e1da9ce5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a282c59eda2b3dc7f4d7eef4e1da9ce5a">reserve</a> (const SizesType &amp;reserveSizes)</td></tr>
<tr class="separator:a282c59eda2b3dc7f4d7eef4e1da9ce5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d57d4dc301bede1a94187d7fef076d" id="r_ae0d57d4dc301bede1a94187d7fef076d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0d57d4dc301bede1a94187d7fef076d">reserve</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> reserveSize)</td></tr>
<tr class="separator:ae0d57d4dc301bede1a94187d7fef076d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09f0131acaa1d71b3c8a6e8fb734221" id="r_ad09f0131acaa1d71b3c8a6e8fb734221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad09f0131acaa1d71b3c8a6e8fb734221">resize</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="#a5b7c78810cadca82fecf5006b096a1c4">rows</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="#a2f948d44f9dbb7d156755592722f778a">cols</a>)</td></tr>
<tr class="separator:ad09f0131acaa1d71b3c8a6e8fb734221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7c78810cadca82fecf5006b096a1c4" id="r_a5b7c78810cadca82fecf5006b096a1c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b7c78810cadca82fecf5006b096a1c4">rows</a> () const</td></tr>
<tr class="separator:a5b7c78810cadca82fecf5006b096a1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c6b1ee045d58ced163b140b9c6bf36" id="r_a39c6b1ee045d58ced163b140b9c6bf36"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators &gt; </td></tr>
<tr class="memitem:a39c6b1ee045d58ced163b140b9c6bf36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39c6b1ee045d58ced163b140b9c6bf36">setFromSortedTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end)</td></tr>
<tr class="separator:a39c6b1ee045d58ced163b140b9c6bf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73841eccfc1066680c7bed8bf98ec3e1" id="r_a73841eccfc1066680c7bed8bf98ec3e1"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators , typename DupFunctor &gt; </td></tr>
<tr class="memitem:a73841eccfc1066680c7bed8bf98ec3e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73841eccfc1066680c7bed8bf98ec3e1">setFromSortedTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end, DupFunctor dup_func)</td></tr>
<tr class="separator:a73841eccfc1066680c7bed8bf98ec3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f09e3597f37aa8861599260af6a53e0" id="r_a8f09e3597f37aa8861599260af6a53e0"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators &gt; </td></tr>
<tr class="memitem:a8f09e3597f37aa8861599260af6a53e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f09e3597f37aa8861599260af6a53e0">setFromTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end)</td></tr>
<tr class="separator:a8f09e3597f37aa8861599260af6a53e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8c96b7dd72d03f14b5cf40f5005d55" id="r_a3e8c96b7dd72d03f14b5cf40f5005d55"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators , typename DupFunctor &gt; </td></tr>
<tr class="memitem:a3e8c96b7dd72d03f14b5cf40f5005d55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e8c96b7dd72d03f14b5cf40f5005d55">setFromTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end, DupFunctor dup_func)</td></tr>
<tr class="separator:a3e8c96b7dd72d03f14b5cf40f5005d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b432c208cc30494347b256456b9bf8" id="r_ac5b432c208cc30494347b256456b9bf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5b432c208cc30494347b256456b9bf8">setIdentity</a> ()</td></tr>
<tr class="separator:ac5b432c208cc30494347b256456b9bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b0b669332724c5d8856d64660a3a8f" id="r_a81b0b669332724c5d8856d64660a3a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81b0b669332724c5d8856d64660a3a8f">setZero</a> ()</td></tr>
<tr class="separator:a81b0b669332724c5d8856d64660a3a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777b062a789ac4c20ce1af870cee0f3b" id="r_a777b062a789ac4c20ce1af870cee0f3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a777b062a789ac4c20ce1af870cee0f3b">SparseMatrix</a> ()</td></tr>
<tr class="separator:a777b062a789ac4c20ce1af870cee0f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51160e5744fe28ceb049500e72f42d88" id="r_a51160e5744fe28ceb049500e72f42d88"><td class="memTemplParams" colspan="2"><a id="a51160e5744fe28ceb049500e72f42d88" name="a51160e5744fe28ceb049500e72f42d88"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a51160e5744fe28ceb049500e72f42d88"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SparseMatrix</b> (const <a class="el" href="classEigen_1_1DiagonalBase.html">DiagonalBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a51160e5744fe28ceb049500e72f42d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with in-place evaluation. <br /></td></tr>
<tr class="separator:a51160e5744fe28ceb049500e72f42d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92082cde4e3f110bbab2c4418779c22" id="r_ab92082cde4e3f110bbab2c4418779c22"><td class="memTemplParams" colspan="2"><a id="ab92082cde4e3f110bbab2c4418779c22" name="ab92082cde4e3f110bbab2c4418779c22"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ab92082cde4e3f110bbab2c4418779c22"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SparseMatrix</b> (const ReturnByValue&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:ab92082cde4e3f110bbab2c4418779c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with in-place evaluation. <br /></td></tr>
<tr class="separator:ab92082cde4e3f110bbab2c4418779c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98fb33504044be169c4c275bf2ee8c4" id="r_ae98fb33504044be169c4c275bf2ee8c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae98fb33504044be169c4c275bf2ee8c4">SparseMatrix</a> (const <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:ae98fb33504044be169c4c275bf2ee8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424a42ee570a9341b6a6d91e09675077" id="r_a424a42ee570a9341b6a6d91e09675077"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a424a42ee570a9341b6a6d91e09675077"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a424a42ee570a9341b6a6d91e09675077">SparseMatrix</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a424a42ee570a9341b6a6d91e09675077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a655cf88c1f45ab0f03ba0493d314e" id="r_a45a655cf88c1f45ab0f03ba0493d314e"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived , unsigned int UpLo&gt; </td></tr>
<tr class="memitem:a45a655cf88c1f45ab0f03ba0493d314e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45a655cf88c1f45ab0f03ba0493d314e">SparseMatrix</a> (const <a class="el" href="classEigen_1_1SparseSelfAdjointView.html">SparseSelfAdjointView</a>&lt; OtherDerived, UpLo &gt; &amp;other)</td></tr>
<tr class="separator:a45a655cf88c1f45ab0f03ba0493d314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ebe8610f28749e1a2ed12f7c364c88" id="r_af8ebe8610f28749e1a2ed12f7c364c88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8ebe8610f28749e1a2ed12f7c364c88">SparseMatrix</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="#a5b7c78810cadca82fecf5006b096a1c4">rows</a>, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="#a2f948d44f9dbb7d156755592722f778a">cols</a>)</td></tr>
<tr class="separator:af8ebe8610f28749e1a2ed12f7c364c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ead26f545fc15f0ef45b934fa278a8" id="r_a32ead26f545fc15f0ef45b934fa278a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32ead26f545fc15f0ef45b934fa278a8">SparseMatrix</a> (<a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a> &amp;&amp;other)</td></tr>
<tr class="separator:a32ead26f545fc15f0ef45b934fa278a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b635a54bf2fe66facd1cb1872aae9f" id="r_ad2b635a54bf2fe66facd1cb1872aae9f"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2b635a54bf2fe66facd1cb1872aae9f">sum</a> () const</td></tr>
<tr class="separator:ad2b635a54bf2fe66facd1cb1872aae9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af873f4a56ce4bf4f7585c4ccea3b41ad" id="r_af873f4a56ce4bf4f7585c4ccea3b41ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af873f4a56ce4bf4f7585c4ccea3b41ad">swap</a> (<a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:af873f4a56ce4bf4f7585c4ccea3b41ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c6e863c29e446a800fbb8ac384f5bf" id="r_aa2c6e863c29e446a800fbb8ac384f5bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2c6e863c29e446a800fbb8ac384f5bf">uncompress</a> ()</td></tr>
<tr class="separator:aa2c6e863c29e446a800fbb8ac384f5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81da93a927da01fb237ee9931574db12" id="r_a81da93a927da01fb237ee9931574db12"><td class="memItemLeft" align="right" valign="top">Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81da93a927da01fb237ee9931574db12">valuePtr</a> ()</td></tr>
<tr class="separator:a81da93a927da01fb237ee9931574db12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b75307b1c38e7be57c72d56955a445b" id="r_a1b75307b1c38e7be57c72d56955a445b"><td class="memItemLeft" align="right" valign="top">const Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b75307b1c38e7be57c72d56955a445b">valuePtr</a> () const</td></tr>
<tr class="separator:a1b75307b1c38e7be57c72d56955a445b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0659579b33b028984a544e5c76ef9c" id="r_a3c0659579b33b028984a544e5c76ef9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c0659579b33b028984a544e5c76ef9c">~SparseMatrix</a> ()</td></tr>
<tr class="separator:a3c0659579b33b028984a544e5c76ef9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1SparseCompressedBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classEigen_1_1SparseCompressedBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1SparseCompressedBase.html">Eigen::SparseCompressedBase&lt; SparseMatrix&lt; Scalar_, Options_, int &gt; &gt;</a></td></tr>
<tr class="memitem:ab3aab863f97c48455bdf12b7d6b14b83 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_ab3aab863f97c48455bdf12b7d6b14b83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Map.html">Map</a>&lt; <a class="el" href="classEigen_1_1Array.html">Array</a>&lt; Scalar, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#ab3aab863f97c48455bdf12b7d6b14b83">coeffs</a> ()</td></tr>
<tr class="separator:ab3aab863f97c48455bdf12b7d6b14b83 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcefacdb594bc96e016eb66f74f93aad inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_adcefacdb594bc96e016eb66f74f93aad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Map.html">Map</a>&lt; const <a class="el" href="classEigen_1_1Array.html">Array</a>&lt; Scalar, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#adcefacdb594bc96e016eb66f74f93aad">coeffs</a> () const</td></tr>
<tr class="separator:adcefacdb594bc96e016eb66f74f93aad inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e88baeeffa067c76bcabd7793352895 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a3e88baeeffa067c76bcabd7793352895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a3e88baeeffa067c76bcabd7793352895">innerIndexPtr</a> ()</td></tr>
<tr class="separator:a3e88baeeffa067c76bcabd7793352895 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29104d325f0d4928fa159257183b2f53 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a29104d325f0d4928fa159257183b2f53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a29104d325f0d4928fa159257183b2f53">innerIndexPtr</a> () const</td></tr>
<tr class="separator:a29104d325f0d4928fa159257183b2f53 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1d8d0da2d3dce54c4c12437082b5e0 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a0b1d8d0da2d3dce54c4c12437082b5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a0b1d8d0da2d3dce54c4c12437082b5e0">innerIndicesAreSorted</a> () const</td></tr>
<tr class="separator:a0b1d8d0da2d3dce54c4c12437082b5e0 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7305a52de7bc970d08d7f6257a3c2508 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a7305a52de7bc970d08d7f6257a3c2508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7305a52de7bc970d08d7f6257a3c2508">innerIndicesAreSorted</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> begin, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> end) const</td></tr>
<tr class="separator:a7305a52de7bc970d08d7f6257a3c2508 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0368c7130d15fbdc1837d6141e1c89e3 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a0368c7130d15fbdc1837d6141e1c89e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a0368c7130d15fbdc1837d6141e1c89e3">innerNonZeroPtr</a> ()</td></tr>
<tr class="separator:a0368c7130d15fbdc1837d6141e1c89e3 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b0aebe77ad28609e715f84d50b0fb6 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_ab8b0aebe77ad28609e715f84d50b0fb6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#ab8b0aebe77ad28609e715f84d50b0fb6">innerNonZeroPtr</a> () const</td></tr>
<tr class="separator:ab8b0aebe77ad28609e715f84d50b0fb6 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837934b33a80fe996ff20500373d3a61 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a837934b33a80fe996ff20500373d3a61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a837934b33a80fe996ff20500373d3a61">isCompressed</a> () const</td></tr>
<tr class="separator:a837934b33a80fe996ff20500373d3a61 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03de8b3da2c142ce8698a76123b3e7d3 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a03de8b3da2c142ce8698a76123b3e7d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a03de8b3da2c142ce8698a76123b3e7d3">nonZeros</a> () const</td></tr>
<tr class="separator:a03de8b3da2c142ce8698a76123b3e7d3 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc894ad59034a6233048338732747afe inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_acc894ad59034a6233048338732747afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#acc894ad59034a6233048338732747afe">outerIndexPtr</a> ()</td></tr>
<tr class="separator:acc894ad59034a6233048338732747afe inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90208df76cc1c9b8d6ada53fea913de9 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a90208df76cc1c9b8d6ada53fea913de9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a90208df76cc1c9b8d6ada53fea913de9">outerIndexPtr</a> () const</td></tr>
<tr class="separator:a90208df76cc1c9b8d6ada53fea913de9 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461216c1edc9c0d80e938735b8f0a28c inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a461216c1edc9c0d80e938735b8f0a28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a461216c1edc9c0d80e938735b8f0a28c">sortInnerIndices</a> ()</td></tr>
<tr class="separator:a461216c1edc9c0d80e938735b8f0a28c inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82100447fe5a514f17b508ac1d21a3f inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_aa82100447fe5a514f17b508ac1d21a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#aa82100447fe5a514f17b508ac1d21a3f">sortInnerIndices</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> begin, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> end)</td></tr>
<tr class="separator:aa82100447fe5a514f17b508ac1d21a3f inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99f79283d649526977b6058caead4cc inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_aa99f79283d649526977b6058caead4cc"><td class="memItemLeft" align="right" valign="top">Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#aa99f79283d649526977b6058caead4cc">valuePtr</a> ()</td></tr>
<tr class="separator:aa99f79283d649526977b6058caead4cc inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6373c1dab09c6d3db8fe5e4eea060a86 inherit pub_methods_classEigen_1_1SparseCompressedBase" id="r_a6373c1dab09c6d3db8fe5e4eea060a86"><td class="memItemLeft" align="right" valign="top">const Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#a6373c1dab09c6d3db8fe5e4eea060a86">valuePtr</a> () const</td></tr>
<tr class="separator:a6373c1dab09c6d3db8fe5e4eea060a86 inherit pub_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1SparseMatrixBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classEigen_1_1SparseMatrixBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase&lt; SparseMatrix&lt; Scalar_, Options_, int &gt; &gt;</a></td></tr>
<tr class="memitem:aca7ce296424ef6e478ab0fb19547a7ee inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_aca7ce296424ef6e478ab0fb19547a7ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aca7ce296424ef6e478ab0fb19547a7ee">cols</a> () const</td></tr>
<tr class="separator:aca7ce296424ef6e478ab0fb19547a7ee inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef28adeb655eacfc605255b25db0282 inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_adef28adeb655eacfc605255b25db0282"><td class="memItemLeft" align="right" valign="top">const internal::eval&lt; <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Options_, int &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#adef28adeb655eacfc605255b25db0282">eval</a> () const</td></tr>
<tr class="separator:adef28adeb655eacfc605255b25db0282 inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180fcba1ccf3cdf3252a263bc1de7a1d inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_a180fcba1ccf3cdf3252a263bc1de7a1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a180fcba1ccf3cdf3252a263bc1de7a1d">innerSize</a> () const</td></tr>
<tr class="separator:a180fcba1ccf3cdf3252a263bc1de7a1d inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eedffa867031f649fd0fb9cc23ce4be inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_a7eedffa867031f649fd0fb9cc23ce4be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a7eedffa867031f649fd0fb9cc23ce4be">isVector</a> () const</td></tr>
<tr class="separator:a7eedffa867031f649fd0fb9cc23ce4be inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4d71b3f34389e6fc01f2b86e43f7a4 inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_a9d4d71b3f34389e6fc01f2b86e43f7a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Options_, int &gt;, OtherDerived, AliasFreeProduct &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a9d4d71b3f34389e6fc01f2b86e43f7a4">operator*</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a9d4d71b3f34389e6fc01f2b86e43f7a4 inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86cc88a4cfef21db6b64ec0ab4c8f0a inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_ac86cc88a4cfef21db6b64ec0ab4c8f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ac86cc88a4cfef21db6b64ec0ab4c8f0a">outerSize</a> () const</td></tr>
<tr class="separator:ac86cc88a4cfef21db6b64ec0ab4c8f0a inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d0414b56d9d620ce9a698c1b281e5d inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_ac8d0414b56d9d620ce9a698c1b281e5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseView.html">SparseView</a>&lt; <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Options_, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ac8d0414b56d9d620ce9a698c1b281e5d">pruned</a> (const Scalar &amp;reference=Scalar(0), const RealScalar &amp;epsilon=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const</td></tr>
<tr class="separator:ac8d0414b56d9d620ce9a698c1b281e5d inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1944e9fa9ce7937bfc3a87b2cb94371f inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_a1944e9fa9ce7937bfc3a87b2cb94371f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1944e9fa9ce7937bfc3a87b2cb94371f">rows</a> () const</td></tr>
<tr class="separator:a1944e9fa9ce7937bfc3a87b2cb94371f inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124bc57921775eb9aa2dfd9727e23472 inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_a124bc57921775eb9aa2dfd9727e23472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a124bc57921775eb9aa2dfd9727e23472">size</a> () const</td></tr>
<tr class="separator:a124bc57921775eb9aa2dfd9727e23472 inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad244a709f56230a8030b078a7ee889c6 inherit pub_methods_classEigen_1_1SparseMatrixBase" id="r_ad244a709f56230a8030b078a7ee889c6"><td class="memItemLeft" align="right" valign="top">SparseSymmetricPermutationProduct&lt; <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Options_, int &gt;, <a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>|<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ad244a709f56230a8030b078a7ee889c6">twistedBy</a> (const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationMatrix</a>&lt; <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> &gt; &amp;perm) const</td></tr>
<tr class="separator:ad244a709f56230a8030b078a7ee889c6 inherit pub_methods_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structEigen_1_1EigenBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_structEigen_1_1EigenBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structEigen_1_1EigenBase.html">Eigen::EigenBase&lt; SparseMatrix&lt; Scalar_, Options_, int &gt; &gt;</a></td></tr>
<tr class="memitem:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_structEigen_1_1EigenBase" id="r_a2d768a9877f5f69f49432d447b552bfe"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a2d768a9877f5f69f49432d447b552bfe">cols</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:a2d768a9877f5f69f49432d447b552bfe inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b057c52245e486a101868d2578a24 inherit pub_methods_structEigen_1_1EigenBase" id="r_a749b057c52245e486a101868d2578a24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Options_, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a749b057c52245e486a101868d2578a24">derived</a> ()</td></tr>
<tr class="separator:a749b057c52245e486a101868d2578a24 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_structEigen_1_1EigenBase" id="r_af9be7c19c7d1c415e18b0e0c7aca1e04"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Options_, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#af9be7c19c7d1c415e18b0e0c7aca1e04">derived</a> () const</td></tr>
<tr class="separator:af9be7c19c7d1c415e18b0e0c7aca1e04 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_structEigen_1_1EigenBase" id="r_ac22eb0695d00edd7d4a3b2d0a98b81c2"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ac22eb0695d00edd7d4a3b2d0a98b81c2 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_structEigen_1_1EigenBase" id="r_ae106171b6fefd3f7af108a8283de36c9"><td class="memItemLeft" align="right" valign="top">EIGEN_CONSTEXPR <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#ae106171b6fefd3f7af108a8283de36c9">size</a> () const EIGEN_NOEXCEPT</td></tr>
<tr class="separator:ae106171b6fefd3f7af108a8283de36c9 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classEigen_1_1SparseMatrixBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classEigen_1_1SparseMatrixBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase&lt; SparseMatrix&lt; Scalar_, Options_, int &gt; &gt;</a></td></tr>
<tr class="memitem:a0b540ba724726ebe953f8c0df06081ed inherit pub_types_classEigen_1_1SparseMatrixBase" id="r_a0b540ba724726ebe953f8c0df06081ed"><td class="memItemLeft" align="right" valign="top">typedef internal::traits&lt; <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Options_, int &gt; &gt;::StorageIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a></td></tr>
<tr class="separator:a0b540ba724726ebe953f8c0df06081ed inherit pub_types_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac254d3b61718ebc2136d27bac043dcb7 inherit pub_types_classEigen_1_1SparseMatrixBase" id="r_ac254d3b61718ebc2136d27bac043dcb7"><td class="memItemLeft" align="right" valign="top">typedef Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ac254d3b61718ebc2136d27bac043dcb7">value_type</a></td></tr>
<tr class="separator:ac254d3b61718ebc2136d27bac043dcb7 inherit pub_types_classEigen_1_1SparseMatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structEigen_1_1EigenBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_structEigen_1_1EigenBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structEigen_1_1EigenBase.html">Eigen::EigenBase&lt; SparseMatrix&lt; Scalar_, Options_, int &gt; &gt;</a></td></tr>
<tr class="memitem:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase" id="r_a554f30542cc2316add4b1ea0a492ff02"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a></td></tr>
<tr class="memdesc:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface type of indices.  <br /></td></tr>
<tr class="separator:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEigen_1_1SparseCompressedBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classEigen_1_1SparseCompressedBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEigen_1_1SparseCompressedBase.html">Eigen::SparseCompressedBase&lt; SparseMatrix&lt; Scalar_, Options_, int &gt; &gt;</a></td></tr>
<tr class="memitem:af79f020db965367d97eb954fc68d8f99 inherit pro_methods_classEigen_1_1SparseCompressedBase" id="r_af79f020db965367d97eb954fc68d8f99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseCompressedBase.html#af79f020db965367d97eb954fc68d8f99">SparseCompressedBase</a> ()</td></tr>
<tr class="separator:af79f020db965367d97eb954fc68d8f99 inherit pro_methods_classEigen_1_1SparseCompressedBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a777b062a789ac4c20ce1af870cee0f3b" name="a777b062a789ac4c20ce1af870cee0f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777b062a789ac4c20ce1af870cee0f3b">&#9670;&#160;</a></span>SparseMatrix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::SparseMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor yielding an empty <code>0</code> <code>x</code> <code>0</code> matrix </p>

</div>
</div>
<a id="af8ebe8610f28749e1a2ed12f7c364c88" name="af8ebe8610f28749e1a2ed12f7c364c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ebe8610f28749e1a2ed12f7c364c88">&#9670;&#160;</a></span>SparseMatrix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <em>rows</em> <code>x</code> <em>cols</em> empty matrix </p>

</div>
</div>
<a id="a424a42ee570a9341b6a6d91e09675077" name="a424a42ee570a9341b6a6d91e09675077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424a42ee570a9341b6a6d91e09675077">&#9670;&#160;</a></span>SparseMatrix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a sparse matrix from the sparse expression <em>other</em> </p>

</div>
</div>
<a id="a45a655cf88c1f45ab0f03ba0493d314e" name="a45a655cf88c1f45ab0f03ba0493d314e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a655cf88c1f45ab0f03ba0493d314e">&#9670;&#160;</a></span>SparseMatrix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived , unsigned int UpLo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseSelfAdjointView.html">SparseSelfAdjointView</a>&lt; OtherDerived, UpLo &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a sparse matrix from the sparse selfadjoint view <em>other</em> </p>

</div>
</div>
<a id="a32ead26f545fc15f0ef45b934fa278a8" name="a32ead26f545fc15f0ef45b934fa278a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ead26f545fc15f0ef45b934fa278a8">&#9670;&#160;</a></span>SparseMatrix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor </p>

</div>
</div>
<a id="ae98fb33504044be169c4c275bf2ee8c4" name="ae98fb33504044be169c4c275bf2ee8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98fb33504044be169c4c275bf2ee8c4">&#9670;&#160;</a></span>SparseMatrix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor (it performs a deep copy) </p>

</div>
</div>
<a id="a3c0659579b33b028984a544e5c76ef9c" name="a3c0659579b33b028984a544e5c76ef9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0659579b33b028984a544e5c76ef9c">&#9670;&#160;</a></span>~SparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::~<a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d58dec51f8325bd203a9fb2f3f288f1" name="a9d58dec51f8325bd203a9fb2f3f288f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d58dec51f8325bd203a9fb2f3f288f1">&#9670;&#160;</a></span>coeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::coeff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value of the matrix at position <em>i</em>, <em>j</em> This function returns Scalar(0) if the element is an explicit <em>zero</em> </dd></dl>

</div>
</div>
<a id="a4bb57000a80870035263c87afe6da8d7" name="a4bb57000a80870035263c87afe6da8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb57000a80870035263c87afe6da8d7">&#9670;&#160;</a></span>coeffRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar &amp; <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::coeffRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const reference to the value of the matrix at position <em>i</em>, <em>j</em> </dd></dl>
<p>If the element does not exist then it is inserted via the <a class="el" href="#ae2d8f72ff86a300b76f9edd67df8d8fd">insert(Index,Index)</a> function which itself turns the matrix into a non compressed form if that was not the case.</p>
<p>This is a O(log(nnz_j)) operation (binary search) plus the cost of <a class="el" href="#ae2d8f72ff86a300b76f9edd67df8d8fd">insert(Index,Index)</a> function if the element does not already exist. </p>

</div>
</div>
<a id="a2f948d44f9dbb7d156755592722f778a" name="a2f948d44f9dbb7d156755592722f778a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f948d44f9dbb7d156755592722f778a">&#9670;&#160;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::cols </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of columns of the matrix </dd></dl>

</div>
</div>
<a id="a7d5792eed86aa5e34b949f112f456f0d" name="a7d5792eed86aa5e34b949f112f456f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5792eed86aa5e34b949f112f456f0d">&#9670;&#160;</a></span>conservativeResize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::conservativeResize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to a <em>rows</em> x <em>cols</em> matrix leaving old values untouched.</p>
<p>If the sizes of the matrix are decreased, then the matrix is turned to <b>uncompressed-mode</b> and the storage of the out of bounds coefficients is kept and reserved. Call <a class="el" href="#a12a042a1c981a6421e25f9a1e6dd6571">makeCompressed()</a> to pack the entries and squeeze extra memory.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae0d57d4dc301bede1a94187d7fef076d">reserve()</a>, <a class="el" href="#a81b0b669332724c5d8856d64660a3a8f">setZero()</a>, <a class="el" href="#a12a042a1c981a6421e25f9a1e6dd6571">makeCompressed()</a> </dd></dl>

</div>
</div>
<a id="af4032edc53a1c79ef3aa6dfe1d7b400c" name="af4032edc53a1c79ef3aa6dfe1d7b400c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4032edc53a1c79ef3aa6dfe1d7b400c">&#9670;&#160;</a></span>diagonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Diagonal.html">DiagonalReturnType</a> <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-write expression of the diagonal coefficients. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the diagonal entries are written, then all diagonal entries <b>must</b> already exist, otherwise an assertion will be raised. </dd></dl>

</div>
</div>
<a id="a95b1325c3ebe1e7ef2e547917e33d055" name="a95b1325c3ebe1e7ef2e547917e33d055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b1325c3ebe1e7ef2e547917e33d055">&#9670;&#160;</a></span>diagonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Diagonal.html">ConstDiagonalReturnType</a> <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const expression of the diagonal coefficients. </dd></dl>

</div>
</div>
<a id="a23d48c2794ae0e6348928152e3929b49" name="a23d48c2794ae0e6348928152e3929b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d48c2794ae0e6348928152e3929b49">&#9670;&#160;</a></span>findOrInsertCoeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar &amp; <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::findOrInsertCoeff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>inserted</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const reference to the value of the matrix at position <em>i</em>, <em>j</em>.</dd></dl>
<p>If the element does not exist then it is inserted via the <a class="el" href="#ae2d8f72ff86a300b76f9edd67df8d8fd">insert(Index,Index)</a> function which itself turns the matrix into a non compressed form if that was not the case. The output parameter <code>inserted</code> is set to true.</p>
<p>Otherwise, if the element does exist, <code>inserted</code> will be set to false.</p>
<p>This is a O(log(nnz_j)) operation (binary search) plus the cost of <a class="el" href="#ae2d8f72ff86a300b76f9edd67df8d8fd">insert(Index,Index)</a> function if the element does not already exist. </p>

</div>
</div>
<a id="a94e39927097b34d15a08a41f8ab130cb" name="a94e39927097b34d15a08a41f8ab130cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e39927097b34d15a08a41f8ab130cb">&#9670;&#160;</a></span>innerIndexPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> * <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::innerIndexPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1b75307b1c38e7be57c72d56955a445b">valuePtr()</a>, <a class="el" href="#a52d9e4e0d99997f46db7d90cab141b27">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a1a048622e2c86790cd33836af6d5eb6f" name="a1a048622e2c86790cd33836af6d5eb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a048622e2c86790cd33836af6d5eb6f">&#9670;&#160;</a></span>innerIndexPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> * <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::innerIndexPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1b75307b1c38e7be57c72d56955a445b">valuePtr()</a>, <a class="el" href="#a52d9e4e0d99997f46db7d90cab141b27">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a6423d60110f5aed0bc9d693c6245da4c" name="a6423d60110f5aed0bc9d693c6245da4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6423d60110f5aed0bc9d693c6245da4c">&#9670;&#160;</a></span>innerNonZeroPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> * <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::innerNonZeroPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it returns the null pointer 0 in compressed mode </dd></dl>

</div>
</div>
<a id="a5c15bd5763aaa9cbf0e619610ec4a0e8" name="a5c15bd5763aaa9cbf0e619610ec4a0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c15bd5763aaa9cbf0e619610ec4a0e8">&#9670;&#160;</a></span>innerNonZeroPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> * <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::innerNonZeroPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it returns the null pointer 0 in compressed mode </dd></dl>

</div>
</div>
<a id="a93f8b9e657a05468dcaae1446ec2a6fc" name="a93f8b9e657a05468dcaae1446ec2a6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f8b9e657a05468dcaae1446ec2a6fc">&#9670;&#160;</a></span>innerSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::innerSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of rows (resp. columns) of the matrix if the storage order column major (resp. row major) </dd></dl>

</div>
</div>
<a id="ae2d8f72ff86a300b76f9edd67df8d8fd" name="ae2d8f72ff86a300b76f9edd67df8d8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d8f72ff86a300b76f9edd67df8d8fd">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::Scalar &amp; <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to a novel non zero coefficient with coordinates <em>row</em> x <em>col</em>. The non zero coefficient must <b>not</b> already exist.</dd></dl>
<p>If the matrix <code>*this</code> is in compressed mode, then <code>*this</code> is turned into uncompressed mode while reserving room for 2 x this-&gt;<a class="el" href="#a93f8b9e657a05468dcaae1446ec2a6fc">innerSize()</a> non zeros if <a class="el" href="#ae0d57d4dc301bede1a94187d7fef076d">reserve(Index)</a> has not been called earlier. In this case, the insertion procedure is optimized for a <em>sequential</em> insertion mode where elements are assumed to be inserted by increasing outer-indices.</p>
<p>If that's not the case, then it is strongly recommended to either use a triplet-list to assemble the matrix, or to first call <a class="el" href="#a282c59eda2b3dc7f4d7eef4e1da9ce5a">reserve(const SizesType &amp;)</a> to reserve the appropriate number of non-zero elements per inner vector.</p>
<p>Assuming memory has been appropriately reserved, this function performs a sorted insertion in O(1) if the elements of each inner vector are inserted in increasing inner index order, and in O(nnz_j) for a random insertion. </p>

</div>
</div>
<a id="a5983337b43e23cf688a00a23e30cfffb" name="a5983337b43e23cf688a00a23e30cfffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5983337b43e23cf688a00a23e30cfffb">&#9670;&#160;</a></span>insertFromSortedTriplets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::insertFromSortedTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as insertFromTriplets but triplets are assumed to be pre-sorted. This is faster and requires less temporary storage. Two triplets <code>a</code> and <code>b</code> are appropriately ordered if: </p><div class="fragment"><div class="line"> <a class="code hl_enumvalue" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>: ((a.col() != b.col()) ? (a.col() &lt;</div>
<div class="line">b.col()) : (a.row() &lt; b.row()) <a class="code hl_enumvalue" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>: ((a.row() != b.row()) ? (a.row() &lt; b.row()) : (a.col() &lt; b.col()) </div>
<div class="ttc" id="agroup__enums_html_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62"><div class="ttname"><a href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">Eigen::ColMajor</a></div><div class="ttdeci">@ ColMajor</div><div class="ttdef"><b>Definition</b> Constants.h:318</div></div>
<div class="ttc" id="agroup__enums_html_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f"><div class="ttname"><a href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">Eigen::RowMajor</a></div><div class="ttdeci">@ RowMajor</div><div class="ttdef"><b>Definition</b> Constants.h:320</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a29f17d24f224a1fb73ab903e2a42aba4" name="a29f17d24f224a1fb73ab903e2a42aba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f17d24f224a1fb73ab903e2a42aba4">&#9670;&#160;</a></span>insertFromSortedTriplets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators , typename DupFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::insertFromSortedTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DupFunctor</td>          <td class="paramname"><span class="paramname"><em>dup_func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as insertFromSortedTriplets but when duplicates are met the functor <em>dup_func</em> is applied: </p><div class="fragment"><div class="line">value = dup_func(OldValue, NewValue)</div>
</div><!-- fragment --><p> Here is a C++11 example keeping the latest entry only: </p><div class="fragment"><div class="line">mat.insertFromSortedTriplets(triplets.begin(), triplets.end(), [] (<span class="keyword">const</span> Scalar&amp;,<span class="keyword">const</span> Scalar &amp;b) { return b; });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af5bf43559efce09f5415d6b66aa31d53" name="af5bf43559efce09f5415d6b66aa31d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bf43559efce09f5415d6b66aa31d53">&#9670;&#160;</a></span>insertFromTriplets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::insertFromTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a batch of elements into the matrix <code>*this</code> with the list of <em>triplets</em> defined in the half-open range from <em>begin</em> to <em>end</em>.</p>
<p>A <em>triplet</em> is a tuple (i,j,value) defining a non-zero element. The input list of triplets does not have to be sorted, and may contain duplicated elements. In any case, the result is a <b>sorted</b> and <b>compressed</b> sparse matrix where the duplicates have been summed up. This is a <em>O(n)</em> operation, with <em>n</em> the number of triplet elements. The initial contents of <code>*this</code> are preserved (except for the summation of duplicate elements). The matrix <code>*this</code> must be properly sized beforehand. The sizes are not extracted from the triplet list.</p>
<p>The <em>InputIterators</em> value_type must provide the following interface: </p><div class="fragment"><div class="line">Scalar value() <span class="keyword">const</span>; <span class="comment">// the value</span></div>
<div class="line">IndexType row() <span class="keyword">const</span>;   <span class="comment">// the row index i</span></div>
<div class="line">IndexType col() <span class="keyword">const</span>;   <span class="comment">// the column index j</span></div>
</div><!-- fragment --><p> See for instance the <a class="el" href="classEigen_1_1Triplet.html" title="A small structure to hold a non zero as a triplet (i,j,value).">Eigen::Triplet</a> template class.</p>
<p>Here is a typical usage example: </p><div class="fragment"><div class="line">SparseMatrixType m(<a class="code hl_function" href="#a5b7c78810cadca82fecf5006b096a1c4">rows</a>,<a class="code hl_function" href="#a2f948d44f9dbb7d156755592722f778a">cols</a>); <span class="comment">// m contains nonzero entries</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classEigen_1_1Triplet.html">Triplet&lt;double&gt;</a> T;</div>
<div class="line">std::vector&lt;T&gt; tripletList;</div>
<div class="line">tripletList.reserve(estimation_of_entries);</div>
<div class="line"><span class="keywordflow">for</span>(...)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  tripletList.push_back(T(i,j,v_ij));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">m.insertFromTriplets(tripletList.begin(), tripletList.end());</div>
<div class="line"><span class="comment">// m is ready to go!</span></div>
<div class="ttc" id="aclassEigen_1_1SparseMatrix_html_a2f948d44f9dbb7d156755592722f778a"><div class="ttname"><a href="#a2f948d44f9dbb7d156755592722f778a">Eigen::SparseMatrix::cols</a></div><div class="ttdeci">Index cols() const</div><div class="ttdef"><b>Definition</b> SparseMatrix.h:161</div></div>
<div class="ttc" id="aclassEigen_1_1SparseMatrix_html_a5b7c78810cadca82fecf5006b096a1c4"><div class="ttname"><a href="#a5b7c78810cadca82fecf5006b096a1c4">Eigen::SparseMatrix::rows</a></div><div class="ttdeci">Index rows() const</div><div class="ttdef"><b>Definition</b> SparseMatrix.h:159</div></div>
<div class="ttc" id="aclassEigen_1_1Triplet_html"><div class="ttname"><a href="classEigen_1_1Triplet.html">Eigen::Triplet</a></div><div class="ttdoc">A small structure to hold a non zero as a triplet (i,j,value).</div><div class="ttdef"><b>Definition</b> SparseUtil.h:187</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The list of triplets is read multiple times (at least twice). Therefore, it is not recommended to define an abstract iterator over a complex data-structure that would be expensive to evaluate. The triplets should rather be explicitly stored into a std::vector for instance. </dd></dl>

</div>
</div>
<a id="ab452919fafc44dc6f8407fe4e5ffeddd" name="ab452919fafc44dc6f8407fe4e5ffeddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab452919fafc44dc6f8407fe4e5ffeddd">&#9670;&#160;</a></span>insertFromTriplets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators , typename DupFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::insertFromTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DupFunctor</td>          <td class="paramname"><span class="paramname"><em>dup_func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as insertFromTriplets but when duplicates are met the functor <em>dup_func</em> is applied: </p><div class="fragment"><div class="line">value = dup_func(OldValue, NewValue)</div>
</div><!-- fragment --><p> Here is a C++11 example keeping the latest entry only: </p><div class="fragment"><div class="line">mat.insertFromTriplets(triplets.begin(), triplets.end(), [] (<span class="keyword">const</span> Scalar&amp;,<span class="keyword">const</span> Scalar &amp;b) { return b; });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a837934b33a80fe996ff20500373d3a61" name="a837934b33a80fe996ff20500373d3a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837934b33a80fe996ff20500373d3a61">&#9670;&#160;</a></span>isCompressed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1SparseCompressedBase.html">Eigen::SparseCompressedBase</a>&lt; Derived &gt;::isCompressed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>*this</code> is in compressed form. </dd></dl>

</div>
</div>
<a id="a12a042a1c981a6421e25f9a1e6dd6571" name="a12a042a1c981a6421e25f9a1e6dd6571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a042a1c981a6421e25f9a1e6dd6571">&#9670;&#160;</a></span>makeCompressed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::makeCompressed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the matrix into the <em>compressed</em> format. </p>

</div>
</div>
<a id="a03de8b3da2c142ce8698a76123b3e7d3" name="a03de8b3da2c142ce8698a76123b3e7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03de8b3da2c142ce8698a76123b3e7d3">&#9670;&#160;</a></span>nonZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1SparseCompressedBase.html">Eigen::SparseCompressedBase</a>&lt; Derived &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of non zero coefficients </dd></dl>

</div>
</div>
<a id="a52d9e4e0d99997f46db7d90cab141b27" name="a52d9e4e0d99997f46db7d90cab141b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d9e4e0d99997f46db7d90cab141b27">&#9670;&#160;</a></span>outerIndexPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> * <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::outerIndexPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1b75307b1c38e7be57c72d56955a445b">valuePtr()</a>, <a class="el" href="#a1a048622e2c86790cd33836af6d5eb6f">innerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="ac3aaff931f31ce89c1af572ff9cc40f3" name="ac3aaff931f31ce89c1af572ff9cc40f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3aaff931f31ce89c1af572ff9cc40f3">&#9670;&#160;</a></span>outerIndexPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> * <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::outerIndexPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1b75307b1c38e7be57c72d56955a445b">valuePtr()</a>, <a class="el" href="#a1a048622e2c86790cd33836af6d5eb6f">innerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a609a0a5e82d875b49135b28b519ed32c" name="a609a0a5e82d875b49135b28b519ed32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609a0a5e82d875b49135b28b519ed32c">&#9670;&#160;</a></span>outerSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::outerSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of columns (resp. rows) of the matrix if the storage order column major (resp. row major) </dd></dl>

</div>
</div>
<a id="aa5d324253a9bc6cffe9a090c8a6b07be" name="aa5d324253a9bc6cffe9a090c8a6b07be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d324253a9bc6cffe9a090c8a6b07be">&#9670;&#160;</a></span>prune() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<div class="memtemplate">
template&lt;typename KeepFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">const KeepFunc &amp;</td>          <td class="paramname"><span class="paramname"><em>keep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">KeepFunc()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the matrix into compressed format, and suppresses all nonzeros which do not satisfy the predicate <em>keep</em>. The functor type <em>KeepFunc</em> must implement the following function: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&amp; row, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&amp; col, <span class="keyword">const</span> Scalar&amp; value) <span class="keyword">const</span>;</div>
<div class="ttc" id="anamespaceEigen_html_a62e77e0933482dafde8fe197d9a2cfde"><div class="ttname"><a href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a></div><div class="ttdeci">EIGEN_DEFAULT_DENSE_INDEX_TYPE Index</div><div class="ttdoc">The Index type as used for the API.</div><div class="ttdef"><b>Definition</b> Meta.h:83</div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>prune(Scalar,RealScalar) </dd></dl>

</div>
</div>
<a id="a2fdc29889aed7b071d7a4066349466f0" name="a2fdc29889aed7b071d7a4066349466f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdc29889aed7b071d7a4066349466f0">&#9670;&#160;</a></span>prune() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;</td>          <td class="paramname"><span class="paramname"><em>reference</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;RealScalar&gt;::dummy_precision()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Suppresses all nonzeros which are <b>much</b> <b>smaller</b> <b>than</b> <em>reference</em> under the tolerance <em>epsilon</em> </p>

</div>
</div>
<a id="a282c59eda2b3dc7f4d7eef4e1da9ce5a" name="a282c59eda2b3dc7f4d7eef4e1da9ce5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282c59eda2b3dc7f4d7eef4e1da9ce5a">&#9670;&#160;</a></span>reserve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<div class="memtemplate">
template&lt;class SizesType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const SizesType &amp;</td>          <td class="paramname"><span class="paramname"><em>reserveSizes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Preallocates <em>reserveSize</em>[<code>j</code>] non zeros for each column (resp. row) <code>j</code>.</p>
<p>This function turns the matrix in non-compressed mode.</p>
<p>The type <code>SizesType</code> must expose the following interface: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classEigen_1_1SparseMatrixBase.html#ac254d3b61718ebc2136d27bac043dcb7">value_type</a>;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="classEigen_1_1SparseMatrixBase.html#ac254d3b61718ebc2136d27bac043dcb7">value_type</a>&amp; operator[](i) <span class="keyword">const</span>;</div>
<div class="ttc" id="aclassEigen_1_1SparseMatrixBase_html_ac254d3b61718ebc2136d27bac043dcb7"><div class="ttname"><a href="classEigen_1_1SparseMatrixBase.html#ac254d3b61718ebc2136d27bac043dcb7">Eigen::SparseMatrixBase&lt; SparseMatrix&lt; Scalar_, Options_, int &gt; &gt;::value_type</a></div><div class="ttdeci">Scalar value_type</div><div class="ttdef"><b>Definition</b> SparseMatrixBase.h:37</div></div>
</div><!-- fragment --><p> for <code>i</code> in the [0,this-&gt;<a class="el" href="#a609a0a5e82d875b49135b28b519ed32c">outerSize()</a>[ range. Typical choices include std::vector&lt;int&gt;, <a class="el" href="group__matrixtypedefs.html#ga4d9e4611379e7304bc276dd8bbbfe08c" title="Dynamic1 vector of type int.">Eigen::VectorXi</a>, <a class="el" href="classEigen_1_1DenseBase.html#a68a7ece6c5629d1e9447a321fcb14ccd">Eigen::VectorXi::Constant</a>, etc. </p>

</div>
</div>
<a id="ae0d57d4dc301bede1a94187d7fef076d" name="ae0d57d4dc301bede1a94187d7fef076d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d57d4dc301bede1a94187d7fef076d">&#9670;&#160;</a></span>reserve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>reserveSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Preallocates <em>reserveSize</em> non zeros.</p>
<p>Precondition: the matrix must be in compressed mode. </p>

</div>
</div>
<a id="ad09f0131acaa1d71b3c8a6e8fb734221" name="ad09f0131acaa1d71b3c8a6e8fb734221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09f0131acaa1d71b3c8a6e8fb734221">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to a <em>rows</em> x <em>cols</em> matrix and initializes it to zero.</p>
<p>This function does not free the currently allocated memory. To release as much as memory as possible, call </p><div class="fragment"><div class="line">mat.data().squeeze(); </div>
</div><!-- fragment --><p> after resizing it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae0d57d4dc301bede1a94187d7fef076d">reserve()</a>, <a class="el" href="#a81b0b669332724c5d8856d64660a3a8f">setZero()</a> </dd></dl>

</div>
</div>
<a id="a5b7c78810cadca82fecf5006b096a1c4" name="a5b7c78810cadca82fecf5006b096a1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7c78810cadca82fecf5006b096a1c4">&#9670;&#160;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::rows </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of rows of the matrix </dd></dl>

</div>
</div>
<a id="a39c6b1ee045d58ced163b140b9c6bf36" name="a39c6b1ee045d58ced163b140b9c6bf36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c6b1ee045d58ced163b140b9c6bf36">&#9670;&#160;</a></span>setFromSortedTriplets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::setFromSortedTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as setFromTriplets but triplets are assumed to be pre-sorted. This is faster and requires less temporary storage. Two triplets <code>a</code> and <code>b</code> are appropriately ordered if: </p><div class="fragment"><div class="line"> <a class="code hl_enumvalue" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>: ((a.col() != b.col()) ? (a.col() &lt;</div>
<div class="line">b.col()) : (a.row() &lt; b.row()) <a class="code hl_enumvalue" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>: ((a.row() != b.row()) ? (a.row() &lt; b.row()) : (a.col() &lt; b.col()) </div>
</div><!-- fragment --> 
</div>
</div>
<a id="a73841eccfc1066680c7bed8bf98ec3e1" name="a73841eccfc1066680c7bed8bf98ec3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73841eccfc1066680c7bed8bf98ec3e1">&#9670;&#160;</a></span>setFromSortedTriplets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators , typename DupFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::setFromSortedTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DupFunctor</td>          <td class="paramname"><span class="paramname"><em>dup_func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as setFromSortedTriplets but when duplicates are met the functor <em>dup_func</em> is applied: </p><div class="fragment"><div class="line">value = dup_func(OldValue, NewValue)</div>
</div><!-- fragment --><p> Here is a C++11 example keeping the latest entry only: </p><div class="fragment"><div class="line">mat.setFromSortedTriplets(triplets.begin(), triplets.end(), [] (<span class="keyword">const</span> Scalar&amp;,<span class="keyword">const</span> Scalar &amp;b) { return b; });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8f09e3597f37aa8861599260af6a53e0" name="a8f09e3597f37aa8861599260af6a53e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f09e3597f37aa8861599260af6a53e0">&#9670;&#160;</a></span>setFromTriplets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::setFromTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the matrix <code>*this</code> with the list of <em>triplets</em> defined in the half-open range from <em>begin</em> to <em>end</em>.</p>
<p>A <em>triplet</em> is a tuple (i,j,value) defining a non-zero element. The input list of triplets does not have to be sorted, and may contain duplicated elements. In any case, the result is a <b>sorted</b> and <b>compressed</b> sparse matrix where the duplicates have been summed up. This is a <em>O(n)</em> operation, with <em>n</em> the number of triplet elements. The initial contents of <code>*this</code> are destroyed. The matrix <code>*this</code> must be properly resized beforehand using the <a class="el" href="#af8ebe8610f28749e1a2ed12f7c364c88">SparseMatrix(Index,Index)</a> constructor, or the <a class="el" href="#ad09f0131acaa1d71b3c8a6e8fb734221">resize(Index,Index)</a> method. The sizes are not extracted from the triplet list.</p>
<p>The <em>InputIterators</em> value_type must provide the following interface: </p><div class="fragment"><div class="line">Scalar value() <span class="keyword">const</span>; <span class="comment">// the value</span></div>
<div class="line">IndexType row() <span class="keyword">const</span>;   <span class="comment">// the row index i</span></div>
<div class="line">IndexType col() <span class="keyword">const</span>;   <span class="comment">// the column index j</span></div>
</div><!-- fragment --><p> See for instance the <a class="el" href="classEigen_1_1Triplet.html" title="A small structure to hold a non zero as a triplet (i,j,value).">Eigen::Triplet</a> template class.</p>
<p>Here is a typical usage example: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classEigen_1_1Triplet.html">Triplet&lt;double&gt;</a> T;</div>
<div class="line">std::vector&lt;T&gt; tripletList;</div>
<div class="line">tripletList.reserve(estimation_of_entries);</div>
<div class="line"><span class="keywordflow">for</span>(...)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  tripletList.push_back(T(i,j,v_ij));</div>
<div class="line">}</div>
<div class="line">SparseMatrixType m(<a class="code hl_function" href="#a5b7c78810cadca82fecf5006b096a1c4">rows</a>,<a class="code hl_function" href="#a2f948d44f9dbb7d156755592722f778a">cols</a>);</div>
<div class="line">m.setFromTriplets(tripletList.begin(), tripletList.end());</div>
<div class="line"><span class="comment">// m is ready to go!</span></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The list of triplets is read multiple times (at least twice). Therefore, it is not recommended to define an abstract iterator over a complex data-structure that would be expensive to evaluate. The triplets should rather be explicitly stored into a std::vector for instance. </dd></dl>

</div>
</div>
<a id="a3e8c96b7dd72d03f14b5cf40f5005d55" name="a3e8c96b7dd72d03f14b5cf40f5005d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8c96b7dd72d03f14b5cf40f5005d55">&#9670;&#160;</a></span>setFromTriplets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators , typename DupFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::setFromTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DupFunctor</td>          <td class="paramname"><span class="paramname"><em>dup_func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as setFromTriplets but when duplicates are met the functor <em>dup_func</em> is applied: </p><div class="fragment"><div class="line">value = dup_func(OldValue, NewValue)</div>
</div><!-- fragment --><p> Here is a C++11 example keeping the latest entry only: </p><div class="fragment"><div class="line">mat.setFromTriplets(triplets.begin(), triplets.end(), [] (<span class="keyword">const</span> Scalar&amp;,<span class="keyword">const</span> Scalar &amp;b) { return b; });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac5b432c208cc30494347b256456b9bf8" name="ac5b432c208cc30494347b256456b9bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b432c208cc30494347b256456b9bf8">&#9670;&#160;</a></span>setIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::setIdentity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets *this to the identity matrix. This function also turns the matrix into compressed mode, and drop any reserved memory. </p>

</div>
</div>
<a id="a81b0b669332724c5d8856d64660a3a8f" name="a81b0b669332724c5d8856d64660a3a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b0b669332724c5d8856d64660a3a8f">&#9670;&#160;</a></span>setZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::setZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all non zeros but keep allocated memory</p>
<p>This function does not free the currently allocated memory. To release as much as memory as possible, call </p><div class="fragment"><div class="line">mat.data().squeeze(); </div>
</div><!-- fragment --><p> after resizing it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad09f0131acaa1d71b3c8a6e8fb734221">resize(Index,Index)</a>, data() </dd></dl>

</div>
</div>
<a id="ad2b635a54bf2fe66facd1cb1872aae9f" name="ad2b635a54bf2fe66facd1cb1872aae9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b635a54bf2fe66facd1cb1872aae9f">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Options_, Index_ &gt; &gt;::Scalar <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, Index_ &gt;::sum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded for performance </p>

</div>
</div>
<a id="af873f4a56ce4bf4f7585c4ccea3b41ad" name="af873f4a56ce4bf4f7585c4ccea3b41ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af873f4a56ce4bf4f7585c4ccea3b41ad">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps the content of two sparse matrices of the same type. This is a fast operation that simply swaps the underlying pointers and parameters. </p>

</div>
</div>
<a id="aa2c6e863c29e446a800fbb8ac384f5bf" name="aa2c6e863c29e446a800fbb8ac384f5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c6e863c29e446a800fbb8ac384f5bf">&#9670;&#160;</a></span>uncompress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::uncompress </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the matrix into the uncompressed mode </p>

</div>
</div>
<a id="a81da93a927da01fb237ee9931574db12" name="a81da93a927da01fb237ee9931574db12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81da93a927da01fb237ee9931574db12">&#9670;&#160;</a></span>valuePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar * <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::valuePtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of values. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1a048622e2c86790cd33836af6d5eb6f">innerIndexPtr()</a>, <a class="el" href="#a52d9e4e0d99997f46db7d90cab141b27">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a1b75307b1c38e7be57c72d56955a445b" name="a1b75307b1c38e7be57c72d56955a445b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b75307b1c38e7be57c72d56955a445b">&#9670;&#160;</a></span>valuePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Flags_ = 0, typename StorageIndex_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Scalar * <a class="el" href="classEigen_1_1SparseMatrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Flags_, StorageIndex_ &gt;::valuePtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of values. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1a048622e2c86790cd33836af6d5eb6f">innerIndexPtr()</a>, <a class="el" href="#a52d9e4e0d99997f46db7d90cab141b27">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SparseMatrix_8h_source.html">SparseMatrix.h</a></li>
<li><a class="el" href="SparseUtil_8h_source.html">SparseUtil.h</a></li>
<li><a class="el" href="SparseRedux_8h_source.html">SparseRedux.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a></li>
    <li class="footer">Generated on Mon Sep 23 2024 01:14:47 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
